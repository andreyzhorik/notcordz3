<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>notcord â€” updated</title>
  <link rel="icon" href="logo-theme2.svg" />
  <style>
    :root{
      --theme-1:#071226; --theme-2:#07101a; --theme-3:#0b2233;
      --muted:#9aa4b2; --accent:#5865f2; --me-bg:#2b3440; --border:rgba(255,255,255,0.06);
      --text:#e6eef6; --idle-yellow:#f0c419;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Helvetica,Arial;color:var(--text);
      background:linear-gradient(180deg,var(--theme-1),var(--theme-2));}
    .app{display:grid;grid-template-columns:260px 1fr 260px;height:100vh;gap:0;min-height:0}
    .sidebar{padding:14px;display:flex;flex-direction:column;gap:12px;background:linear-gradient(180deg,var(--theme-1),var(--theme-2));border-right:1px solid var(--border);overflow:auto}
    .brand{display:flex;gap:10px;align-items:center;font-weight:800}
    .brand .logo{width:26px;height:26px;border-radius:6px;background:var(--theme-2);display:flex;align-items:center;justify-content:center;font-weight:900}
    .channels{display:flex;flex-direction:column;gap:6px;margin-top:8px}
    .channel{padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer;border:1px solid transparent;display:flex;justify-content:space-between;align-items:center}
    .channel.active{background:linear-gradient(90deg, rgba(88,101,242,0.12), rgba(88,101,242,0.02));color:var(--text);border-color:rgba(88,101,242,0.12)}
    .playersPanel{padding:14px;background:linear-gradient(180deg,var(--theme-1),var(--theme-2));border-left:1px solid var(--border);overflow:auto}
    .chatPanel{display:flex;flex-direction:column;min-height:0}
    .header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px}
    .messages{flex:1;overflow:auto;padding:20px;display:flex;flex-direction:column;gap:12px;min-height:0}
    .message{display:flex;gap:12px;align-items:flex-start;max-width:85%}
    .message.me{margin-left:auto;justify-content:flex-end}
    .authorAvatar{width:36px;height:36px;border-radius:8px;object-fit:cover;background:rgba(255,255,255,0.03)}
    .bubble{background:var(--theme-3);color:var(--text);padding:10px 12px;border-radius:12px;display:flex;flex-direction:column;gap:6px;max-width:520px;word-break:break-word}
    .meta{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
    .meta .name{font-weight:700}
    .text{white-space:pre-wrap;color:inherit;font-size:15px;word-break:break-word}
    .replyTag{font-size:12px;color:var(--muted);margin-top:6px;padding-left:6px;border-left:2px solid rgba(255,255,255,0.03)}
    .photoMessage img{max-width:420px;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.3);cursor:pointer;max-height:480px;width:auto;display:block}
    .inputArea{padding:12px;border-top:1px solid var(--border);display:flex;gap:8px;align-items:flex-end;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .inputArea textarea{flex:1;min-height:44px;max-height:160px;resize:none;padding:10px;border-radius:10px;background:transparent;border:1px solid var(--border);color:inherit;outline:none}
    .sendBtn{background:var(--accent);border:none;color:white;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600}
    .sendBtn:disabled{opacity:0.6;cursor:default}
    .photoUploadArea{padding:12px;border-top:1px solid var(--border);display:flex;gap:8px;align-items:center;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .playersList{display:flex;flex-direction:column;gap:8px}
    .player{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid transparent}
    .statusDot{width:10px;height:10px;border-radius:50%;flex-shrink:0}
    .player.online .statusDot{background:#39d353;box-shadow:0 0 8px rgba(57,211,83,0.12)}
    .player.idle .statusDot{background:var(--idle-yellow);box-shadow:0 0 8px rgba(240,196,25,0.12)}
    .player.offline .statusDot{background:#a0a0a0}
    .pinnedSection{padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid var(--border);font-size:13px}
    .pinnedItem{padding:6px;border-radius:6px;background:rgba(255,255,255,0.01);display:flex;gap:8px;align-items:center}
    .replyBtn{margin-left:8px;font-size:12px;color:var(--muted);background:transparent;border:none;cursor:pointer}
    .mentionHighlight{background:rgba(240,196,25,0.12);color:var(--idle-yellow);padding:2px 4px;border-radius:4px}
    @media (max-width:980px){ .app{grid-template-columns:200px 1fr 140px} }
    @media (max-width:720px){ .app{grid-template-columns:1fr} .sidebar,.playersPanel{display:none} }
  </style>
</head>
<body>
  <div class="app" id="app">
    <aside class="sidebar">
      <div class="brand">
        <div class="logo" id="logo">N</div>
        <div>notcord</div>
      </div>

      <div id="userSection">
        <div id="usernameBox" style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <input id="usernameInput" type="text" placeholder="Choose username (max 8 chars)" maxlength="8" style="flex:1;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)" />
          <button id="setNameBtn" class="sendBtn" style="padding:8px 10px">Set</button>
        </div>

        <div id="usernameLocked" style="display:none;gap:8px;align-items:center;margin-top:8px">
          <img id="userAvatarSmall" class="authorAvatar" src="" alt="avatar" style="width:36px;height:36px;border-radius:8px" />
          <div style="display:flex;flex-direction:column">
            <div id="usernameDisplay" style="font-weight:700"></div>
            <div style="font-size:12px;color:var(--muted)" id="nameChangeInfo"></div>
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <label style="font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px">Change avatar (weekly)
            <input type="file" id="avatarInput" accept="image/*" />
          </label>
          <button id="changeNameBtn" style="padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer">Change Name</button>
        </div>
      </div>

      <div class="channels" id="channels" style="margin-top:12px">
        <div class="channel active" data-id="general"># general</div>
        <div class="channel" data-id="photos"># photos</div>
        <!-- removed # announcements and # general 2 -->
      </div>

      <div style="margin-top:auto">
        <div class="pinnedSection" id="pinnedSection" style="display:none;margin-top:10px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">Pinned</div>
            <div><button id="clearPins" style="background:transparent;border:1px solid var(--border);padding:4px 6px;border-radius:6px;color:var(--muted);cursor:pointer">Clear</button></div>
          </div>
          <div id="pinnedList" style="margin-top:8px;display:flex;flex-direction:column;gap:6px"></div>
        </div>
      </div>
    </aside>

    <section class="chatPanel">
      <div class="header">
        <h2 id="channelTitle"># general</h2>
        <div style="flex:1"></div>
        <div style="display:flex;flex-direction:column;align-items:flex-end">
          <div id="status" style="font-size:13px;color:var(--muted)">Disconnected</div>
          <div id="typingIndicator" style="font-size:12px;color:var(--muted);height:18px"></div>
        </div>
      </div>

      <div class="messages" id="messages" role="log" aria-atomic="false"></div>

      <div class="inputArea" id="inputArea">
        <textarea id="messageInput" placeholder="Message (Shift+Enter for newline)" maxlength="500"></textarea>
        <div style="display:flex;flex-direction:column;gap:8px;align-items:flex-end">
          <div id="charCount" style="font-size:12px;color:var(--muted)">0 / 500</div>
          <button id="sendBtn" class="sendBtn" disabled>Send</button>
        </div>
      </div>

      <div class="photoUploadArea" id="photoUploadArea" style="display:none">
        <input id="photoInput" type="file" accept="image/*,image/gif" />
        <button id="uploadPhotoBtn" class="sendBtn" disabled>Upload Photo / GIF</button>
      </div>
    </section>

    <aside class="playersPanel">
      <h3 style="margin:0;color:var(--muted)">Players</h3>
      <div id="playersList" class="playersList" style="margin-top:8px"></div>
    </aside>
  </div>

  <!-- Socket.IO client from CDN (if server serves local copy replace src) -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    (function(){
      // Configuration
      const API_BASE = ''; // same origin
      const MAX_NAME_LEN = 8;
      const NAME_CHANGE_KEY = 'notcord_name_change_ts_server';
      const AVATAR_CHANGE_KEY = 'notcord_avatar_change_ts_server';
      const CLIENT_TOKEN_KEY = 'notcord_client_token_v1';
      const PINS_KEY = 'notcord_pins_local_v1';
      const TYPING_EXPIRE_MS = 5000;

      // DOM refs
      const channelsEl = document.getElementById('channels');
      const messagesEl = document.getElementById('messages');
      const channelTitle = document.getElementById('channelTitle');
      const statusEl = document.getElementById('status');
      const typingIndicatorEl = document.getElementById('typingIndicator');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const charCountEl = document.getElementById('charCount');
      const inputArea = document.getElementById('inputArea');
      const photoUploadArea = document.getElementById('photoUploadArea');
      const photoInput = document.getElementById('photoInput');
      const uploadPhotoBtn = document.getElementById('uploadPhotoBtn');

      const usernameBox = document.getElementById('usernameBox');
      const usernameInput = document.getElementById('usernameInput');
      const setNameBtn = document.getElementById('setNameBtn');
      const usernameLocked = document.getElementById('usernameLocked');
      const usernameDisplay = document.getElementById('usernameDisplay');
      const userAvatarSmall = document.getElementById('userAvatarSmall');
      const avatarInput = document.getElementById('avatarInput');
      const changeNameBtn = document.getElementById('changeNameBtn');
      const nameChangeInfo = document.getElementById('nameChangeInfo');

      const pinnedSection = document.getElementById('pinnedSection');
      const pinnedList = document.getElementById('pinnedList');
      const clearPinsBtn = document.getElementById('clearPins');

      const playersListEl = document.getElementById('playersList');

      // State
      let activeChannel = localStorage.getItem('notcord_channel') || 'general';
      let clientToken = localStorage.getItem(CLIENT_TOKEN_KEY) || generateClientToken();
      let currentUser = null; // { id, name, nameColor, avatar, nameChangedAt, avatarChangedAt }
      let socket = null;
      let typingMap = {}; // { channel: { name: timestamp } }
      let replyTo = null;
      let pinnedMessages = JSON.parse(localStorage.getItem(PINS_KEY) || '[]');

      // Helpers
      function generateClientToken(){ const t = (crypto && crypto.randomUUID) ? crypto.randomUUID() : 'ct-'+Math.random().toString(36).slice(2); localStorage.setItem(CLIENT_TOKEN_KEY, t); return t; }
      function setStatus(txt){ statusEl.textContent = txt; }
      function now(){ return Date.now(); }
      function fmtTime(iso){ try{ const d=new Date(iso); return d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}); }catch(e){return ''} }
      function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
      function savePins(){ localStorage.setItem(PINS_KEY, JSON.stringify(pinnedMessages)); refreshPinnedUI(); }
      function isMessagePinned(id){ return pinnedMessages.includes(String(id)); }
      function truncate(s,n=60){ return s && s.length>n ? s.slice(0,n-1)+'â€¦' : (s||''); }

      // UI updates
      function setActiveChannelUI(id){
        activeChannel = id;
        localStorage.setItem('notcord_channel', id);
        Array.from(channelsEl.children).forEach(ch => ch.classList.toggle('active', ch.dataset.id === id));
        channelTitle.textContent = '# ' + id;
        if(id === 'photos'){ inputArea.style.display='none'; photoUploadArea.style.display='flex'; } else { inputArea.style.display='flex'; photoUploadArea.style.display='none'; }
        fetchMessages();
      }

      // Render message
      function renderMessage(msg){
        // privacy: if private and not involved skip
        if(msg.privateToId && currentUser && !(String(msg.privateToId) === String(currentUser.id) || String(msg.userId) === String(currentUser.id))) return null;

        const container = document.createElement('div');
        container.className = 'message' + ((currentUser && msg.userName === currentUser.name) ? ' me' : '');
        container.dataset.msgId = msg.id || '';

        const avatar = document.createElement('img'); avatar.className='authorAvatar'; avatar.alt = (msg.userName||'User') + ' avatar';
        avatar.src = msg.avatarUrl || (msg.userName === (currentUser && currentUser.name) ? (currentUser.avatar || '') : '');
        avatar.onerror = ()=> avatar.style.background = 'rgba(255,255,255,0.02)';

        const bubble = document.createElement('div'); bubble.className='bubble';

        const meta = document.createElement('div'); meta.className='meta';
        const nameSpan = document.createElement('span'); nameSpan.className='name'; nameSpan.textContent = msg.userName || 'Unknown';
        if(msg.nameColor) nameSpan.style.color = msg.nameColor;
        const timeSpan = document.createElement('span'); timeSpan.className='time'; timeSpan.style.fontSize='12px'; timeSpan.style.color='var(--muted)'; timeSpan.textContent = fmtTime(msg.createdAt || msg.created_at || msg.created);

        meta.appendChild(nameSpan);
        meta.appendChild(timeSpan);

        // reply button
        if(currentUser && (!msg.privateToId)){
          const replyBtn = document.createElement('button'); replyBtn.className='replyBtn'; replyBtn.textContent='Reply';
          replyBtn.onclick = (e)=>{ e.stopPropagation(); setReplyTo(msg); };
          meta.appendChild(replyBtn);
        }

        bubble.appendChild(meta);

        // show quoted reply preview if available
        if(msg.replyTo && msg.replyTo.userName){
          const r = document.createElement('div'); r.className='replyTag'; r.textContent = `${msg.replyTo.userName}: ${truncate(msg.replyTo.text||msg.replyTo.message,140)}`; bubble.appendChild(r);
        }

        // content
        if(msg.imageUrl){
          const photoDiv = document.createElement('div'); photoDiv.className = 'photoMessage';
          const img = document.createElement('img'); img.src = msg.imageUrl; img.alt = msg.text || 'photo';
          img.onclick = ()=> window.open(img.src, '_blank');
          photoDiv.appendChild(img);
          if(msg.text){
            const caption = document.createElement('div'); caption.className='text'; caption.textContent = msg.text;
            photoDiv.appendChild(caption);
          }
          bubble.appendChild(photoDiv);
        } else {
          const text = document.createElement('div'); text.className='text';
          // highlight mentions of current user
          const content = msg.text || msg.message || '';
          if(currentUser && content.includes('@'+currentUser.name)){
            const parts = content.split(new RegExp('(@'+currentUser.name+')','g'));
            parts.forEach(p=>{
              if(p === '@'+currentUser.name){
                const span = document.createElement('span'); span.className='mentionHighlight'; span.textContent = p; text.appendChild(span);
              } else {
                text.appendChild(document.createTextNode(p));
              }
            });
            // ping visual
            container.style.outline = '2px solid rgba(88,101,242,0.12)';
            setTimeout(()=> container.style.outline = '', 2500);
            setStatus('You were mentioned by ' + (msg.userName || 'someone'));
          } else {
            text.textContent = content;
          }
          bubble.appendChild(text);
        }

        if(isMessagePinned(msg.id)){
          const pin = document.createElement('div'); pin.style.fontSize='12px'; pin.style.color='var(--muted)'; pin.textContent='ðŸ“Œ Pinned'; bubble.appendChild(pin);
        }

        // layout
        const wrapper = document.createElement('div'); wrapper.style.display='flex'; wrapper.style.gap='12px';
        if(container.className.includes('me')){
          wrapper.appendChild(bubble); wrapper.appendChild(avatar);
        } else {
          wrapper.appendChild(avatar); wrapper.appendChild(bubble);
        }
        container.appendChild(wrapper);

        // context menu for pin/unpin
        container.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          togglePin(msg.id).catch(()=>{});
        });

        return container;
      }

      // Fetch messages
      async function fetchMessages(){
        try{
          const res = await fetch(`/api/messages?channel=${encodeURIComponent(activeChannel)}&limit=200`);
          if(!res.ok) throw new Error('Fetch messages failed');
          const data = await res.json();
          messagesEl.innerHTML = '';
          const wasBottom = (messagesEl.scrollTop + messagesEl.clientHeight) >= (messagesEl.scrollHeight - 80);
          for(const m of data){
            const el = renderMessage(m);
            if(el) messagesEl.appendChild(el);
          }
          if(wasBottom) messagesEl.scrollTop = messagesEl.scrollHeight;
          setStatus('Connected â€” ' + data.length + ' messages');
        }catch(e){ setStatus('Error loading messages'); console.error(e); }
      }

      // Post message
      async function postMessage(text){
        if(!currentUser){ setStatus('Set username first'); return; }
        if(!text || !text.trim()) return;
        try{
          const payload = { clientToken, channel: activeChannel, text: text.trim(), replyToId: replyTo ? replyTo.id : null };
          const res = await fetch('/api/messages', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          const j = await res.json();
          if(!res.ok){ setStatus(j.message || 'Failed to send'); return; }
          messageInput.value = ''; updateCharCount();
          clearReply();
          // optimistic: server will broadcast via socket; we still fetch to ensure canonical state
          if(!socket) await fetchMessages();
        }catch(e){ console.error(e); setStatus('Send failed'); }
      }

      // Upload photo (client-side resize for non-GIFs)
      function isGif(file){ return file.type === 'image/gif' || /\.gif$/i.test(file.name); }
      function fileToDataUrl(file){ return new Promise((res, rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); }); }
      function resizeImageDataUrl(dataUrl, maxW=1024, maxH=768){
        return new Promise((res, rej)=>{
          const img = new Image();
          img.onload = ()=>{
            let w = img.width, h = img.height;
            if(w <= maxW && h <= maxH){ res(dataUrl); return; }
            const ratio = Math.min(maxW/w, maxH/h);
            const canvas = document.createElement('canvas'); canvas.width = Math.round(w*ratio); canvas.height = Math.round(h*ratio);
            const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0,canvas.width,canvas.height);
            res(canvas.toDataURL('image/jpeg',0.85));
          };
          img.onerror = rej; img.src = dataUrl;
        });
      }
      async function uploadPhoto(file){
        if(!currentUser){ setStatus('Set username first'); return; }
        try{
          let dataUrl = await fileToDataUrl(file);
          if(!isGif(file)) dataUrl = await resizeImageDataUrl(dataUrl, 1024, 768);
          const body = { clientToken, dataUrl, channel: 'photos' };
          const res = await fetch('/api/uploads/photo', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
          const j = await res.json();
          if(!res.ok){ setStatus(j.message || 'Upload failed'); return; }
          setStatus('Photo uploaded');
          photoInput.value = ''; uploadPhotoBtn.disabled = true;
          await fetchMessages();
        }catch(e){ console.error(e); setStatus('Upload failed'); }
      }

      // Pins
      async function togglePin(messageId){
        try{
          const res = await fetch('/api/pins', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clientToken, channel: activeChannel, messageId }) });
          const j = await res.json();
          if(!res.ok) throw new Error(j.message || 'Pin failed');
          if(j.action === 'pinned') pinnedMessages.push(String(messageId)); else pinnedMessages = pinnedMessages.filter(x=>x !== String(messageId));
          savePins();
          refreshPinnedUI();
          await fetchMessages();
        }catch(e){ console.error(e); setStatus('Pin toggle failed'); }
      }
      function refreshPinnedUI(){
        if(!pinnedMessages.length){ pinnedSection.style.display='none'; pinnedList.innerHTML=''; return; }
        pinnedSection.style.display='block'; pinnedList.innerHTML = '';
        pinnedMessages.forEach(id=>{
          const item = document.createElement('div'); item.className='pinnedItem'; item.textContent = 'Message ID: ' + id;
          const btn = document.createElement('button'); btn.textContent='Unpin'; btn.style.marginLeft='auto'; btn.onclick = ()=>{ togglePin(id); };
          item.appendChild(btn); pinnedList.appendChild(item);
        });
      }

      // Reply handling
      function setReplyTo(msg){
        replyTo = msg;
        messageInput.placeholder = `Replying to ${msg.userName}: "${truncate(msg.text||msg.message||'',60)}" (Esc to cancel)`;
        messageInput.focus();
      }
      function clearReply(){ replyTo = null; messageInput.placeholder = 'Message (Shift+Enter for newline)'; }
      document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') clearReply(); });

      // Name & avatar flows (server-side enforcement)
      async function registerOrUpdateName(name){
        if(!name) return;
        name = name.trim().slice(0, MAX_NAME_LEN);
        try{
          const res = await fetch('/api/auth/register', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clientToken, name }) });
          const j = await res.json();
          if(!res.ok){ if(j.remainingSeconds){ alert('You can change name in ' + Math.ceil(j.remainingSeconds/3600/24) + ' day(s).'); } setStatus(j.message || 'Name change failed'); return; }
          currentUser = j.user;
          localStorage.setItem(NAME_CHANGE_KEY, j.user.nameChangedAt || Date.now());
          onUserSet();
          setStatus('Name set: ' + currentUser.name);
        }catch(e){ console.error(e); setStatus('Name set failed'); }
      }
      async function changeAvatarDataUrl(dataUrl){
        try{
          const res = await fetch('/api/auth/avatar', { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clientToken, dataUrl }) });
          const j = await res.json();
          if(!res.ok){ if(j.remainingSeconds) alert('You can change avatar in ' + Math.ceil(j.remainingSeconds/3600/24) + ' day(s).'); setStatus(j.message || 'Avatar change failed'); return; }
          currentUser = j.user;
          localStorage.setItem(AVATAR_CHANGE_KEY, j.user.avatarChangedAt || Date.now());
          userAvatarSmall.src = currentUser.avatar || '';
          setStatus('Avatar updated');
          if(socket) socket.emit('presence:update', { idle: document.hidden });
        }catch(e){ console.error(e); setStatus('Avatar update failed'); }
      }

      // Socket & realtime
      function initSocket(){
        socket = io(); // same origin
        socket.on('connect', ()=> setStatus('Connected (realtime)'));
        socket.on('disconnect', ()=> setStatus('Disconnected (realtime)'));
        socket.on('message', (msg)=> {
          // If message belongs to current channel render
          if(msg.channel === activeChannel) {
            const el = renderMessage(msg);
            if(el) messagesEl.appendChild(el);
            // keep scroll if near bottom
            messagesEl.scrollTop = messagesEl.scrollHeight;
          }
        });
        socket.on('mention', (payload)=> {
          // payload: { fromName, messageId, channel, text }
          if(payload.channel === activeChannel) setStatus('Mentioned by ' + payload.fromName);
          // optionally show desktop notification
          if(Notification.permission === 'granted'){
            new Notification('Mention from ' + payload.fromName, { body: payload.text.slice(0,120) });
          }
        });
        socket.on('presence', (p)=> { updatePlayersUI(p); });
        // auth on connect
        if(currentUser) socket.emit('auth', { clientToken });
        socket.on('connect_error', ()=> setStatus('Realtime connection error'));
      }

      // Players / presence UI
      function updatePlayersUI(list){
        playersListEl.innerHTML = '';
        // API may return array of { name, online, idle, id, avatar }
        if(!Array.isArray(list)) return;
        const online = list.filter(p=>p.online || p.id == (currentUser && currentUser.id));
        const offline = list.filter(p=>!p.online && !p.idle);
        const idle = list.filter(p=>p.idle);

        const addGroup = (title, items, cls) => {
          const h = document.createElement('div'); h.style.color='var(--muted)'; h.style.fontSize='13px'; h.textContent = title + ' ('+items.length+')';
          playersListEl.appendChild(h);
          items.forEach(p=>{
            const it = document.createElement('div'); it.className='player ' + (p.idle? 'idle' : (p.online? 'online':'offline'));
            const dot = document.createElement('span'); dot.className='statusDot';
            const name = document.createElement('div'); name.innerHTML = escapeHtml(p.name) + ((currentUser && p.name === currentUser.name)?' <small style="color:var(--muted)">(you)</small>':'');
            it.appendChild(dot); it.appendChild(name);
            playersListEl.appendChild(it);
          });
        };
        addGroup('Online', online, 'online');
        addGroup('Idle', idle, 'idle');
        addGroup('Offline', offline, 'offline');
      }

      // Presence: send visibility to server via socket
      function updateVisibility(){
        if(!socket) return;
        socket.emit('visibility', { idle: document.hidden });
      }
      document.addEventListener('visibilitychange', ()=> {
        updateVisibility();
        // clientside idle marker update
        setTimeout(()=> fetchPlayers().catch(()=>{}), 200);
      });

      // Fetch players snapshot from API
      async function fetchPlayers(){
        try{
          const res = await fetch('/api/users/players');
          if(!res.ok) return;
          const j = await res.json();
          updatePlayersUI(j);
        }catch(e){ console.warn(e); }
      }

      // Client registration on load
      async function initUserFromServer(){
        try{
          const res = await fetch('/api/auth/whoami', { headers:{ 'X-Client-Token': clientToken } });
          if(res.status === 404){
            currentUser = null;
            usernameBox.style.display = 'flex'; usernameLocked.style.display='none';
            setStatus('Please set your name');
            return;
          }
          const j = await res.json();
          if(res.ok){
            currentUser = j.user;
            onUserSet();
            setStatus('Welcome back, ' + currentUser.name);
          } else {
            currentUser = null;
          }
        }catch(e){ console.warn(e); currentUser = null; }
      }

      // UI when user set
      function onUserSet(){
        if(!currentUser) return;
        usernameBox.style.display='none'; usernameLocked.style.display='flex'; usernameDisplay.textContent = currentUser.name;
        userAvatarSmall.src = currentUser.avatar || '';
        // notify socket about auth
        if(socket) socket.emit('auth', { clientToken });
        fetchPlayers().catch(()=>{});
      }

      // Event wiring
      channelsEl.addEventListener('click', (e)=> {
        const ch = e.target.closest('.channel');
        if(!ch) return;
        setActiveChannelUI(ch.dataset.id);
        if(socket) socket.emit('join', { channel: ch.dataset.id });
      });

      setNameBtn.addEventListener('click', ()=> {
        const v = (usernameInput.value||'').trim();
        if(!v) return;
        if(v.length > MAX_NAME_LEN) alert('Max name length is ' + MAX_NAME_LEN);
        registerOrUpdateName(v);
      });

      changeNameBtn.addEventListener('click', async ()=> {
        if(!currentUser){ alert('Set a name first'); return; }
        // client asks server for change; server enforces weekly
        const newName = prompt('Enter new name (max ' + MAX_NAME_LEN + ' chars):', currentUser.name);
        if(newName && newName.trim()){
          registerOrUpdateName(newName.trim().slice(0,MAX_NAME_LEN));
        }
      });

      avatarInput.addEventListener('change', async ()=> {
        if(!avatarInput.files.length) return;
        const f = avatarInput.files[0];
        try{
          let dataUrl = await fileToDataUrl(f);
          // resize small avatar
          if(!isGif(f)) dataUrl = await resizeImageDataUrl(dataUrl, 256, 256);
          await changeAvatarDataUrl(dataUrl);
        }catch(e){ console.error(e); alert('Avatar upload failed'); }
        avatarInput.value = '';
      });

      sendBtn.addEventListener('click', ()=> {
        postMessage(messageInput.value);
      });

      messageInput.addEventListener('input', ()=> {
        updateCharCount();
        // typing indicator: broadcast in local storage for cross-tab and via socket
        const map = JSON.parse(localStorage.getItem('notcord_typing_map_v1') || '{}');
        map[activeChannel] = map[activeChannel] || {}; map[activeChannel][currentUser?currentUser.name:''] = Date.now();
        localStorage.setItem('notcord_typing_map_v1', JSON.stringify(map));
        if(socket) socket.emit('typing', { channel: activeChannel });
      });

      messageInput.addEventListener('keydown', (e)=> {
        if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); if(!sendBtn.disabled) sendBtn.click(); }
        if(e.key === 'Escape'){ clearReply(); }
      });

      photoInput.addEventListener('change', ()=> {
        uploadPhotoBtn.disabled = !photoInput.files.length;
      });
      uploadPhotoBtn.addEventListener('click', ()=> {
        if(photoInput.files.length) uploadPhoto(photoInput.files[0]);
      });

      // Pins UI clear
      clearPinsBtn.addEventListener('click', ()=> { pinnedMessages = []; savePins(); fetchMessages(); });

      // Typing UI from local storage (cross-tab)
      window.addEventListener('storage', (e)=> {
        if(e.key === 'notcord_typing_map_v1'){ updateTypingUI(); }
      });
      function updateTypingUI(){
        const map = JSON.parse(localStorage.getItem('notcord_typing_map_v1') || '{}');
        const ch = map[activeChannel] || {};
        const nowTs = Date.now();
        const typers = Object.keys(ch).filter(u => u && (nowTs - ch[u]) <= TYPING_EXPIRE_MS && (!currentUser || u !== currentUser.name));
        if(!typers.length) typingIndicatorEl.textContent = '';
        else typingIndicatorEl.textContent = typers[0] + (typers.length>1 ? (' and ' + (typers.length-1) + ' others are typing...') : ' is typing...');
      }
      setInterval(updateTypingUI, 1500);

      // Fetch players and messages periodically
      setInterval(()=> fetchPlayers().catch(()=>{}), 5000);

      // Character count
      function updateCharCount(){ charCountEl.textContent = (messageInput.value||'').length + ' / 500'; sendBtn.disabled = !(currentUser && (messageInput.value||'').trim()); }

      // Initialization
      (async function init(){
        refreshPinnedUI();
        setActiveChannelUI(activeChannel);
        await initUserFromServer();
        initSocket();
        if(currentUser) socket.emit('join', { channel: activeChannel });
        // request notification permission optional
        if('Notification' in window && Notification.permission === 'default') {
          try{ await Notification.requestPermission(); }catch(e){}
        }
        // initial players/messages fetch
        await fetchMessages();
        await fetchPlayers();
        // update visibility presence
        if(socket) socket.emit('visibility', { idle: document.hidden });
      })();

      // Expose minimal debug
      window._notcord = { clientToken, currentUser, fetchMessages, fetchPlayers, pinnedMessages };

    })();
  </script>
</body>
</html>
