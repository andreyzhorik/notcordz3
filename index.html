<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>notcord â€” updated</title>
  <link rel="icon" href="logo-theme2.svg" />
  <style>
    :root{
      --theme-1:#071226; --theme-2:#07101a; --theme-3:#0b2233;
      --muted:#9aa4b2; --accent:#5865f2; --me-bg:#2b3440; --border:rgba(255,255,255,0.06);
      --text:#e6eef6; --idle-yellow:#f0c419;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Helvetica,Arial;color:var(--text);
      background:linear-gradient(180deg,var(--theme-1),var(--theme-2));}
    .app{display:grid;grid-template-columns:300px 1fr 260px;height:100vh;gap:0;min-height:0}
    .sidebar{padding:14px;display:flex;flex-direction:column;gap:12px;background:linear-gradient(180deg,var(--theme-1),var(--theme-2));border-right:1px solid var(--border);overflow:auto}
    .brand{display:flex;gap:10px;align-items:center;font-weight:800}
    .brand .logo{width:28px;height:28px;border-radius:6px;background:var(--theme-2);display:flex;align-items:center;justify-content:center;font-weight:900}
    .channels{display:flex;flex-direction:column;gap:6px;margin-top:8px}
    .channel{padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer;border:1px solid transparent;display:flex;justify-content:space-between;align-items:center}
    .channel.active{background:linear-gradient(90deg, rgba(88,101,242,0.12), rgba(88,101,242,0.02));color:var(--text);border-color:rgba(88,101,242,0.12)}
    .playersPanel{padding:14px;background:linear-gradient(180deg,var(--theme-1),var(--theme-2));border-left:1px solid var(--border);overflow:auto}
    .chatPanel{display:flex;flex-direction:column;min-height:0}
    .header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px}
    .messages{flex:1;overflow:auto;padding:20px;display:flex;flex-direction:column;gap:12px;min-height:0}
    .message{display:flex;gap:12px;align-items:flex-start;max-width:85%}
    .message.me{margin-left:auto;justify-content:flex-end}
    .authorAvatar{width:36px;height:36px;border-radius:8px;object-fit:cover;background:rgba(255,255,255,0.03)}
    .bubble{background:var(--theme-3);color:var(--text);padding:10px 12px;border-radius:12px;display:flex;flex-direction:column;gap:6px;max-width:520px;word-break:break-word}
    .meta{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
    .meta .name{font-weight:700}
    .text{white-space:pre-wrap;color:inherit;font-size:15px;word-break:break-word}
    .replyTag{font-size:12px;color:var(--muted);margin-top:6px;padding-left:6px;border-left:2px solid rgba(255,255,255,0.03)}
    .photoMessage img{max-width:420px;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.3);cursor:pointer;max-height:480px;width:auto;display:block}
    .inputArea{padding:12px;border-top:1px solid var(--border);display:flex;gap:8px;align-items:flex-end;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .inputArea textarea{flex:1;min-height:44px;max-height:160px;resize:none;padding:10px;border-radius:10px;background:transparent;border:1px solid var(--border);color:inherit;outline:none}
    .sendBtn{background:var(--accent);border:none;color:white;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600}
    .sendBtn:disabled{opacity:0.6;cursor:default}
    .photoUploadArea{padding:12px;border-top:1px solid var(--border);display:flex;gap:8px;align-items:center;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .playersList{display:flex;flex-direction:column;gap:8px}
    .player{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid transparent}
    .statusDot{width:10px;height:10px;border-radius:50%;flex-shrink:0}
    .player.online .statusDot{background:#39d353;box-shadow:0 0 8px rgba(57,211,83,0.12)}
    .player.idle .statusDot{background:var(--idle-yellow);box-shadow:0 0 8px rgba(240,196,25,0.12)}
    .player.offline .statusDot{background:#a0a0a0}
    .pinnedSection{padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid var(--border);font-size:13px}
    .pinnedItem{padding:6px;border-radius:6px;background:rgba(255,255,255,0.01);display:flex;gap:8px;align-items:center}
    .replyBtn{margin-left:8px;font-size:12px;color:var(--muted);background:transparent;border:none;cursor:pointer}
    .mentionHighlight{background:rgba(240,196,25,0.12);color:var(--idle-yellow);padding:2px 4px;border-radius:4px}
    .settings label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px}
    .settings input[type="color"]{width:48px;height:32px;padding:0;border:none;background:transparent;cursor:pointer}
    @media (max-width:980px){ .app{grid-template-columns:220px 1fr 140px} }
    @media (max-width:720px){ .app{grid-template-columns:1fr} .sidebar,.playersPanel{display:none} }
  </style>
</head>
<body>
  <div class="app" id="app">
    <aside class="sidebar">
      <div class="brand">
        <div class="logo" id="logo">N</div>
        <div>notcord</div>
      </div>

      <div id="userSection">
        <div id="usernameBox" style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <input id="usernameInput" type="text" placeholder="Choose username (max 8 chars)" maxlength="8" style="flex:1;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text)" />
          <button id="setNameBtn" class="sendBtn" style="padding:8px 10px">Set</button>
        </div>

        <div id="usernameLocked" style="display:none;gap:8px;align-items:center;margin-top:8px">
          <img id="userAvatarSmall" class="authorAvatar" src="" alt="avatar" style="width:36px;height:36px;border-radius:8px" />
          <div style="display:flex;flex-direction:column">
            <div id="usernameDisplay" style="font-weight:700"></div>
            <div style="font-size:12px;color:var(--muted)" id="nameChangeInfo"></div>
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <label style="font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px">Change avatar (weekly)
            <input type="file" id="avatarInput" accept="image/*" />
          </label>
          <button id="changeNameBtn" style="padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer">Change Name</button>
        </div>

        <div class="settings" style="margin-top:10px">
          <label>Your name color
            <div style="display:flex;gap:8px;align-items:center">
              <input type="color" id="nameColor" />
              <button id="resetNameColor" style="padding:6px;border-radius:6px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer">Reset</button>
            </div>
          </label>

          <label>Theme color 1
            <div style="display:flex;gap:8px;align-items:center">
              <input type="color" id="theme1" />
              <button id="resetTheme1" style="padding:6px;border-radius:6px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer">Reset</button>
            </div>
          </label>

          <label>Theme color 2
            <div style="display:flex;gap:8px;align-items:center">
              <input type="color" id="theme2" />
              <button id="resetTheme2" style="padding:6px;border-radius:6px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer">Reset</button>
            </div>
          </label>

          <label>Theme color 3 (bubbles)
            <div style="display:flex;gap:8px;align-items:center">
              <input type="color" id="theme3" />
              <button id="resetTheme3" style="padding:6px;border-radius:6px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer">Reset</button>
            </div>
          </label>
        </div>
      </div>

      <div class="channels" id="channels" style="margin-top:12px">
        <div class="channel active" data-id="general"># general</div>
        <div class="channel" data-id="photos"># photos</div>
      </div>

      <div style="margin-top:auto">
        <div class="pinnedSection" id="pinnedSection" style="display:none;margin-top:10px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">Pinned</div>
            <div><button id="clearPins" style="background:transparent;border:1px solid var(--border);padding:4px 6px;border-radius:6px;color:var(--muted);cursor:pointer">Clear</button></div>
          </div>
          <div id="pinnedList" style="margin-top:8px;display:flex;flex-direction:column;gap:6px"></div>
        </div>
      </div>
    </aside>

    <section class="chatPanel">
      <div class="header">
        <h2 id="channelTitle"># general</h2>
        <div style="flex:1"></div>
        <div style="display:flex;flex-direction:column;align-items:flex-end">
          <div id="status" style="font-size:13px;color:var(--muted)">Disconnected</div>
          <div id="typingIndicator" style="font-size:12px;color:var(--muted);height:18px"></div>
        </div>
      </div>

      <div class="messages" id="messages" role="log" aria-atomic="false"></div>

      <div class="inputArea" id="inputArea">
        <textarea id="messageInput" placeholder="Message (Shift+Enter for newline)" maxlength="500"></textarea>
        <div style="display:flex;flex-direction:column;gap:8px;align-items:flex-end">
          <div id="charCount" style="font-size:12px;color:var(--muted)">0 / 500</div>
          <button id="sendBtn" class="sendBtn" disabled>Send</button>
        </div>
      </div>

      <div class="photoUploadArea" id="photoUploadArea" style="display:none">
        <input id="photoInput" type="file" accept="image/*,image/gif" />
        <button id="uploadPhotoBtn" class="sendBtn" disabled>Upload Photo / GIF</button>
      </div>
    </section>

    <aside class="playersPanel">
      <h3 style="margin:0;color:var(--muted)">Players</h3>
      <div id="playersList" class="playersList" style="margin-top:8px"></div>
    </aside>
  </div>

  <!-- Socket.IO client (CDN) -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    (function(){
      // Config & keys
      const CLIENT_TOKEN_KEY = 'notcord_client_token_v1';
      const PINS_KEY = 'notcord_pins_local_v1';
      const TYPING_KEY = 'notcord_typing_map_v1';
      const MAX_NAME_LEN = 8;
      const NAME_CHANGE_KEY = 'notcord_name_change_ts_server';
      const AVATAR_CHANGE_KEY = 'notcord_avatar_change_ts_server';
      const TYPING_EXPIRE_MS = 5000;

      // DOM refs
      const channelsEl = document.getElementById('channels');
      const messagesEl = document.getElementById('messages');
      const channelTitle = document.getElementById('channelTitle');
      const statusEl = document.getElementById('status');
      const typingIndicatorEl = document.getElementById('typingIndicator');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const charCountEl = document.getElementById('charCount');
      const inputArea = document.getElementById('inputArea');
      const photoUploadArea = document.getElementById('photoUploadArea');
      const photoInput = document.getElementById('photoInput');
      const uploadPhotoBtn = document.getElementById('uploadPhotoBtn');

      const usernameBox = document.getElementById('usernameBox');
      const usernameInput = document.getElementById('usernameInput');
      const setNameBtn = document.getElementById('setNameBtn');
      const usernameLocked = document.getElementById('usernameLocked');
      const usernameDisplay = document.getElementById('usernameDisplay');
      const userAvatarSmall = document.getElementById('userAvatarSmall');
      const avatarInput = document.getElementById('avatarInput');
      const changeNameBtn = document.getElementById('changeNameBtn');
      const nameChangeInfo = document.getElementById('nameChangeInfo');

      const pinnedSection = document.getElementById('pinnedSection');
      const pinnedList = document.getElementById('pinnedList');
      const clearPinsBtn = document.getElementById('clearPins');

      const nameColorInput = document.getElementById('nameColor');
      const theme1Input = document.getElementById('theme1');
      const theme2Input = document.getElementById('theme2');
      const theme3Input = document.getElementById('theme3');
      const resetNameColorBtn = document.getElementById('resetNameColor');
      const resetTheme1Btn = document.getElementById('resetTheme1');
      const resetTheme2Btn = document.getElementById('resetTheme2');
      const resetTheme3Btn = document.getElementById('resetTheme3');

      const playersListEl = document.getElementById('playersList');

      // State
      let activeChannel = localStorage.getItem('notcord_channel') || 'general';
      let clientToken = localStorage.getItem(CLIENT_TOKEN_KEY) || generateClientToken();
      let currentUser = null;
      let socket = null;
      let pinnedMessages = JSON.parse(localStorage.getItem(PINS_KEY) || '[]');
      let replyTo = null;

      // Theme and name color defaults
      let nameColor = localStorage.getItem('notcord_nameColor') || '#ffcc00';
      let theme1 = localStorage.getItem('notcord_theme1') || getComputedStyle(document.documentElement).getPropertyValue('--theme-1').trim() || '#071226';
      let theme2 = localStorage.getItem('notcord_theme2') || getComputedStyle(document.documentElement).getPropertyValue('--theme-2').trim() || '#07101a';
      let theme3 = localStorage.getItem('notcord_theme3') || getComputedStyle(document.documentElement).getPropertyValue('--theme-3').trim() || '#0b2233';

      // Helpers
      function generateClientToken(){ const t = (crypto && crypto.randomUUID) ? crypto.randomUUID() : 'ct-'+Math.random().toString(36).slice(2); localStorage.setItem(CLIENT_TOKEN_KEY, t); return t; }
      function setStatus(txt){ statusEl.textContent = txt; }
      function now(){ return Date.now(); }
      function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
      function fmtTime(iso){ try{ const d=new Date(iso); return d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}); }catch(e){return ''} }

      // Theme application
      function applyTheme(){
        document.documentElement.style.setProperty('--theme-1', theme1);
        document.documentElement.style.setProperty('--theme-2', theme2);
        document.documentElement.style.setProperty('--theme-3', theme3);
        document.documentElement.style.setProperty('--accent', theme1);
      }
      function initThemeInputs(){
        nameColorInput.value = nameColor;
        theme1Input.value = theme1;
        theme2Input.value = theme2;
        theme3Input.value = theme3;
      }

      // UI helpers
      function setActiveChannelUI(id){
        activeChannel = id;
        localStorage.setItem('notcord_channel', id);
        Array.from(channelsEl.children).forEach(ch => ch.classList.toggle('active', ch.dataset.id === id));
        channelTitle.textContent = '# ' + id;
        if(id === 'photos'){ inputArea.style.display='none'; photoUploadArea.style.display='flex'; } else { inputArea.style.display='flex'; photoUploadArea.style.display='none'; }
        fetchMessages();
        if(socket) socket.emit('join', { channel: id });
      }

      function isMessagePinned(id){ return pinnedMessages.includes(String(id)); }
      function savePins(){ localStorage.setItem(PINS_KEY, JSON.stringify(pinnedMessages)); refreshPinnedUI(); }

      function refreshPinnedUI(){
        if(!pinnedMessages.length){ pinnedSection.style.display='none'; pinnedList.innerHTML=''; return; }
        pinnedSection.style.display='block'; pinnedList.innerHTML='';
        pinnedMessages.forEach(id=>{
          const item = document.createElement('div'); item.className='pinnedItem'; item.textContent = 'Message ID: ' + id;
          const btn = document.createElement('button'); btn.textContent='Unpin'; btn.style.marginLeft='auto'; btn.onclick = ()=> togglePin(id);
          item.appendChild(btn); pinnedList.appendChild(item);
        });
      }

      // Message rendering
      function renderMessage(msg){
        if(msg.privateToId && currentUser && !(String(msg.privateToId) === String(currentUser.id) || String(msg.userId) === String(currentUser.id))) return null;

        const container = document.createElement('div');
        container.className = 'message' + ((currentUser && msg.userName === currentUser.name) ? ' me' : '');
        container.dataset.msgId = msg.id || '';

        const avatar = document.createElement('img'); avatar.className='authorAvatar'; avatar.alt = (msg.userName||'User') + ' avatar';
        avatar.src = msg.avatarUrl || (msg.userName === (currentUser && currentUser.name) ? (currentUser.avatar || '') : '');
        avatar.onerror = ()=> avatar.style.background = 'rgba(255,255,255,0.02)';

        const bubble = document.createElement('div'); bubble.className='bubble';

        const meta = document.createElement('div'); meta.className='meta';
        const nameSpan = document.createElement('span'); nameSpan.className='name'; nameSpan.textContent = msg.userName || 'Unknown';
        if(msg.nameColor) nameSpan.style.color = msg.nameColor;
        else if(currentUser && msg.userName === currentUser.name && nameColor) nameSpan.style.color = nameColor;
        const timeSpan = document.createElement('span'); timeSpan.className='time'; timeSpan.style.fontSize='12px'; timeSpan.style.color='var(--muted)'; timeSpan.textContent = fmtTime(msg.createdAt || msg.created);

        meta.appendChild(nameSpan);
        meta.appendChild(timeSpan);

        if(currentUser && (!msg.privateToId)){
          const replyBtn = document.createElement('button'); replyBtn.className='replyBtn'; replyBtn.textContent='Reply';
          replyBtn.onclick = (e)=> { e.stopPropagation(); setReplyTo(msg); };
          meta.appendChild(replyBtn);
        }

        bubble.appendChild(meta);

        if(msg.replyTo && msg.replyTo.userName){
          const r = document.createElement('div'); r.className='replyTag'; r.textContent = `${msg.replyTo.userName}: ${truncate(msg.replyTo.text||msg.replyTo.message||'',140)}`; bubble.appendChild(r);
        }

        if(msg.imageUrl){
          const photoDiv = document.createElement('div'); photoDiv.className='photoMessage';
          const img = document.createElement('img'); img.src = msg.imageUrl; img.alt = msg.text || 'photo';
          img.onclick = ()=> window.open(img.src, '_blank');
          photoDiv.appendChild(img);
          if(msg.text){
            const caption = document.createElement('div'); caption.className='text'; caption.textContent = msg.text;
            photoDiv.appendChild(caption);
          }
          bubble.appendChild(photoDiv);
        } else {
          const text = document.createElement('div'); text.className='text';
          const content = msg.text || msg.message || '';
          if(currentUser && content.includes('@'+currentUser.name)){
            const parts = content.split(new RegExp('(@'+currentUser.name+')','g'));
            parts.forEach(p=>{
              if(p === '@'+currentUser.name){
                const span = document.createElement('span'); span.className='mentionHighlight'; span.textContent = p; text.appendChild(span);
              } else {
                text.appendChild(document.createTextNode(p));
              }
            });
            container.style.outline = '2px solid rgba(88,101,242,0.12)';
            setTimeout(()=> container.style.outline = '', 2500);
            setStatus('You were mentioned by ' + (msg.userName || 'someone'));
          } else {
            text.textContent = content;
          }
          bubble.appendChild(text);
        }

        if(isMessagePinned(msg.id)){
          const pin = document.createElement('div'); pin.style.fontSize='12px'; pin.style.color='var(--muted)'; pin.textContent='ðŸ“Œ Pinned'; bubble.appendChild(pin);
        }

        const wrapper = document.createElement('div'); wrapper.style.display='flex'; wrapper.style.gap='12px';
        if(container.className.includes('me')){ wrapper.appendChild(bubble); wrapper.appendChild(avatar); } else { wrapper.appendChild(avatar); wrapper.appendChild(bubble); }
        container.appendChild(wrapper);

        container.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          togglePin(msg.id).catch(()=>{});
        });

        return container;
      }

      function truncate(s,n=60){ return s && s.length>n ? s.slice(0,n-1)+'â€¦' : (s||''); }

      // Fetch messages from server
      async function fetchMessages(){
        try{
          const res = await fetch(`/api/messages?channel=${encodeURIComponent(activeChannel)}&limit=200`);
          if(!res.ok) throw new Error('Fetch messages failed: ' + res.status);
          const data = await res.json();
          messagesEl.innerHTML = '';
          const wasBottom = (messagesEl.scrollTop + messagesEl.clientHeight) >= (messagesEl.scrollHeight - 80);
          for(const m of data){
            const el = renderMessage(m);
            if(el) messagesEl.appendChild(el);
          }
          if(wasBottom) messagesEl.scrollTop = messagesEl.scrollHeight;
          setStatus('Connected â€” ' + data.length + ' messages');
        }catch(e){
          console.warn(e);
          setStatus('Could not load messages');
        }
      }

      // Post message
      async function postMessage(text){
        if(!currentUser){ setStatus('Set username first'); return; }
        if(!text || !text.trim()) return;
        try{
          const body = { clientToken, channel: activeChannel, text: text.trim(), replyToId: replyTo ? replyTo.id : null };
          const res = await fetch('/api/messages', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
          const j = await res.json().catch(()=>({}));
          if(!res.ok){ setStatus(j.message || 'Failed to send'); return; }
          messageInput.value = ''; updateCharCount(); clearReply();
          // server will broadcast; to be safe fetch if no socket
          if(!socket) await fetchMessages();
        }catch(e){ console.error(e); setStatus('Send failed'); }
      }

      // Upload photo
      function isGif(file){ return file.type === 'image/gif' || /\.gif$/i.test(file.name); }
      function fileToDataUrl(file){ return new Promise((res, rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); }); }
      function resizeImageDataUrl(dataUrl, maxW=1024, maxH=768){
        return new Promise((res, rej)=>{
          const img = new Image();
          img.onload = ()=>{
            let w = img.width, h = img.height;
            if(w <= maxW && h <= maxH){ res(dataUrl); return; }
            const ratio = Math.min(maxW/w, maxH/h);
            const canvas = document.createElement('canvas'); canvas.width = Math.round(w*ratio); canvas.height = Math.round(h*ratio);
            const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0,canvas.width,canvas.height);
            res(canvas.toDataURL('image/jpeg',0.85));
          };
          img.onerror = rej; img.src = dataUrl;
        });
      }
      async function uploadPhoto(file){
        if(!currentUser){ setStatus('Set username first'); return; }
        try{
          let dataUrl = await fileToDataUrl(file);
          if(!isGif(file)) dataUrl = await resizeImageDataUrl(dataUrl, 1024, 768);
          const res = await fetch('/api/uploads/photo', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clientToken, dataUrl, channel: 'photos' }) });
          const j = await res.json().catch(()=>({}));
          if(!res.ok){ setStatus(j.message || 'Upload failed'); return; }
          setStatus('Photo uploaded');
          photoInput.value = ''; uploadPhotoBtn.disabled = true;
          if(!socket) await fetchMessages();
        }catch(e){ console.error(e); setStatus('Upload failed'); }
      }

      // Pins
      async function togglePin(messageId){
        try{
          const res = await fetch('/api/pins', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clientToken, channel: activeChannel, messageId }) });
          const j = await res.json().catch(()=>({}));
          if(!res.ok) throw new Error(j.message || 'Pin failed');
          if(j.action === 'pinned') pinnedMessages.push(String(messageId)); else pinnedMessages = pinnedMessages.filter(x=>x !== String(messageId));
          savePins();
          if(!socket) fetchMessages().catch(()=>{});
        }catch(e){ console.error(e); setStatus('Pin toggle failed'); }
      }

      // Reply handling
      function setReplyTo(msg){ replyTo = msg; messageInput.placeholder = `Replying to ${msg.userName}: "${truncate(msg.text||msg.message||'',60)}" (Esc to cancel)`; messageInput.focus(); }
      function clearReply(){ replyTo = null; messageInput.placeholder = 'Message (Shift+Enter for newline)'; }
      document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') clearReply(); });

      // Name & avatar (server enforced)
      async function registerOrUpdateName(name){
        if(!name) return;
        name = name.trim().slice(0, MAX_NAME_LEN);
        try{
          const res = await fetch('/api/auth/register', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clientToken, name }) });
          const j = await res.json().catch(()=>({}));
          if(!res.ok){ if(j.remainingSeconds) alert('You can change name in ' + Math.ceil(j.remainingSeconds/3600/24) + ' day(s).'); setStatus(j.message || 'Name change failed'); return; }
          currentUser = j.user;
          localStorage.setItem(NAME_CHANGE_KEY, j.user.nameChangedAt || Date.now());
          onUserSet();
          setStatus('Name set: ' + currentUser.name);
        }catch(e){ console.error(e); setStatus('Name set failed'); }
      }

      async function changeAvatarDataUrl(dataUrl){
        try{
          const res = await fetch('/api/auth/avatar', { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clientToken, dataUrl }) });
          const j = await res.json().catch(()=>({}));
          if(!res.ok){ if(j.remainingSeconds) alert('You can change avatar in ' + Math.ceil(j.remainingSeconds/3600/24) + ' day(s).'); setStatus(j.message || 'Avatar change failed'); return; }
          currentUser = j.user;
          localStorage.setItem(AVATAR_CHANGE_KEY, j.user.avatarChangedAt || Date.now());
          userAvatarSmall.src = currentUser.avatar || '';
          setStatus('Avatar updated');
          if(socket) socket.emit('presence:update', { idle: document.hidden });
        }catch(e){ console.error(e); setStatus('Avatar update failed'); }
      }

      // Socket initialization safely
      function initSocket(){
        try{
          if(typeof io === 'undefined'){ console.warn('Socket.IO client not found'); setStatus('Realtime not available'); return; }
          socket = io();
          socket.on('connect', ()=> { setStatus('Connected (realtime)'); if(currentUser) socket.emit('auth', { clientToken }); socket.emit('join', { channel: activeChannel }); });
          socket.on('disconnect', ()=> setStatus('Disconnected (realtime)'));
          socket.on('message', (msg)=> {
            if(msg.channel === activeChannel){
              const el = renderMessage(msg);
              if(el) { messagesEl.appendChild(el); messagesEl.scrollTop = messagesEl.scrollHeight; }
            }
          });
          socket.on('mention', (payload)=> {
            setStatus('Mentioned by ' + payload.fromName);
            if(Notification.permission === 'granted') new Notification('Mention from ' + payload.fromName, { body: payload.text.slice(0,120) });
          });
          socket.on('presence', (p)=> updatePlayersUI(p));
          socket.on('connect_error', ()=> setStatus('Realtime connection error'));
        }catch(e){ console.error('Socket init error', e); setStatus('Realtime error'); }
      }

      // Players UI
      function updatePlayersUI(list){
        playersListEl.innerHTML = '';
        if(!Array.isArray(list)) return;
        const online = list.filter(p=>p.online);
        const idle = list.filter(p=>p.idle);
        const offline = list.filter(p=>!p.online && !p.idle);

        const addGroup = (title, items) => {
          const h = document.createElement('div'); h.style.color='var(--muted)'; h.style.fontSize='13px'; h.textContent = title + ' ('+items.length+')';
          playersListEl.appendChild(h);
          items.forEach(p=>{
            const it = document.createElement('div'); it.className='player ' + (p.idle? 'idle' : (p.online? 'online':'offline'));
            const dot = document.createElement('span'); dot.className='statusDot';
            const name = document.createElement('div'); name.innerHTML = escapeHtml(p.name) + ((currentUser && p.name === currentUser.name)?' <small style="color:var(--muted)">(you)</small>':'');
            it.appendChild(dot); it.appendChild(name); playersListEl.appendChild(it);
          });
        };
        addGroup('Online', online);
        addGroup('Idle', idle);
        addGroup('Offline', offline);
      }

      async function fetchPlayers(){
        try{
          const res = await fetch('/api/users/players');
          if(!res.ok) return;
          const j = await res.json();
          updatePlayersUI(j);
        }catch(e){ console.warn(e); }
      }

      // Toggle pin (calls server; local fallback)
      async function togglePin(messageId){
        try{
          const res = await fetch('/api/pins', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ clientToken, channel: activeChannel, messageId }) });
          const j = await res.json().catch(()=>({}));
          if(!res.ok) throw new Error(j.message || 'Pin failed');
          if(j.action === 'pinned') pinnedMessages.push(String(messageId)); else pinnedMessages = pinnedMessages.filter(x=>x !== String(messageId));
          savePins();
          if(!socket) fetchMessages().catch(()=>{});
        }catch(e){ console.error(e); setStatus('Pin toggle failed'); }
      }

      // Fetch current user (whoami)
      async function initUserFromServer(){
        try{
          const res = await fetch('/api/auth/whoami', { headers:{ 'X-Client-Token': clientToken } });
          if(res.status === 404){ currentUser = null; usernameBox.style.display='flex'; usernameLocked.style.display='none'; setStatus('Choose a name'); return; }
          const j = await res.json().catch(()=>({}));
          if(res.ok && j.user){ currentUser = j.user; onUserSet(); setStatus('Welcome back, ' + currentUser.name); } else { currentUser = null; }
        }catch(e){ console.warn(e); currentUser = null; }
      }

      function onUserSet(){
        if(!currentUser) return;
        usernameBox.style.display='none'; usernameLocked.style.display='flex'; usernameDisplay.textContent = currentUser.name;
        userAvatarSmall.src = currentUser.avatar || '';
        if(currentUser.nameColor) nameColor = currentUser.nameColor;
        // apply name color to displayed names where appropriate
        Array.from(document.querySelectorAll('.meta .name')).forEach(el => { if(el.textContent === currentUser.name) el.style.color = nameColor; });
      }

      // UI bindings
      channelsEl.addEventListener('click', (e)=> {
        const ch = e.target.closest('.channel');
        if(!ch) return;
        setActiveChannelUI(ch.dataset.id);
      });

      setNameBtn.addEventListener('click', ()=> {
        const v = (usernameInput.value||'').trim();
        if(!v) return;
        if(v.length > MAX_NAME_LEN) alert('Max name length is ' + MAX_NAME_LEN);
        registerOrUpdateName(v);
      });

      changeNameBtn.addEventListener('click', ()=> {
        if(!currentUser){ alert('Set a name first'); return; }
        const newName = prompt('Enter new name (max ' + MAX_NAME_LEN + ' chars):', currentUser.name);
        if(newName && newName.trim()) registerOrUpdateName(newName.trim().slice(0,MAX_NAME_LEN));
      });

      avatarInput.addEventListener('change', async ()=> {
        if(!avatarInput.files.length) return;
        const f = avatarInput.files[0];
        try{
          let dataUrl = await fileToDataUrl(f);
          if(!isGif(f)) dataUrl = await resizeImageDataUrl(dataUrl, 256, 256);
          await changeAvatarDataUrl(dataUrl);
        }catch(e){ console.error(e); alert('Avatar upload failed'); }
        avatarInput.value = '';
      });

      sendBtn.addEventListener('click', ()=> { postMessage(messageInput.value); });
      messageInput.addEventListener('input', ()=> {
        updateCharCount();
        const map = JSON.parse(localStorage.getItem(TYPING_KEY) || '{}');
        map[activeChannel] = map[activeChannel] || {}; map[activeChannel][currentUser?currentUser.name:''] = Date.now();
        localStorage.setItem(TYPING_KEY, JSON.stringify(map));
        if(socket) socket.emit('typing', { channel: activeChannel });
      });
      messageInput.addEventListener('keydown', (e)=> { if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); if(!sendBtn.disabled) sendBtn.click(); } if(e.key==='Escape') clearReply(); });

      photoInput.addEventListener('change', ()=> { uploadPhotoBtn.disabled = !photoInput.files.length; });
      uploadPhotoBtn.addEventListener('click', ()=> { if(photoInput.files.length) uploadPhoto(photoInput.files[0]); });

      clearPinsBtn.addEventListener('click', ()=> { pinnedMessages = []; savePins(); fetchMessages(); });

      // Typing UI cross-tab
      window.addEventListener('storage', (e)=> { if(e.key === TYPING_KEY) updateTypingUI(); });
      function updateTypingUI(){
        const map = JSON.parse(localStorage.getItem(TYPING_KEY) || '{}'); const ch = map[activeChannel] || {}; const nowTs = Date.now();
        const typers = Object.keys(ch).filter(u => u && (nowTs - ch[u]) <= TYPING_EXPIRE_MS && (!currentUser || u !== currentUser.name));
        typingIndicatorEl.textContent = typers.length ? (typers[0] + (typers.length>1 ? (' and ' + (typers.length-1) + ' others are typing...') : ' is typing...')) : '';
      }
      setInterval(updateTypingUI, 1500);

      // Character count
      function updateCharCount(){ charCountEl.textContent = (messageInput.value||'').length + ' / 500'; sendBtn.disabled = !(currentUser && (messageInput.value||'').trim()); }

      // Theme inputs wiring
      initThemeInputs();
      applyTheme();
      function initThemeInputs(){
        nameColorInput.value = nameColor;
        theme1Input.value = theme1;
        theme2Input.value = theme2;
        theme3Input.value = theme3;
      }
      nameColorInput.addEventListener('input', ()=> { nameColor = nameColorInput.value; localStorage.setItem('notcord_nameColor', nameColor); if(currentUser && currentUser.name) currentUser.nameColor = nameColor; Array.from(document.querySelectorAll('.meta .name')).forEach(el=>{ if(el.textContent=== (currentUser && currentUser.name)) el.style.color = nameColor; })});
      resetNameColorBtn.addEventListener('click', ()=> { nameColor = '#ffcc00'; nameColorInput.value = nameColor; localStorage.setItem('notcord_nameColor', nameColor); });

      theme1Input.addEventListener('input', ()=> { theme1 = theme1Input.value; localStorage.setItem('notcord_theme1', theme1); applyTheme(); });
      resetTheme1Btn.addEventListener('click', ()=> { theme1 = '#071226'; theme1Input.value = theme1; localStorage.setItem('notcord_theme1', theme1); applyTheme(); });
      theme2Input.addEventListener('input', ()=> { theme2 = theme2Input.value; localStorage.setItem('notcord_theme2', theme2); applyTheme(); });
      resetTheme2Btn.addEventListener('click', ()=> { theme2 = '#07101a'; theme2Input.value = theme2; localStorage.setItem('notcord_theme2', theme2); applyTheme(); });
      theme3Input.addEventListener('input', ()=> { theme3 = theme3Input.value; localStorage.setItem('notcord_theme3', theme3); applyTheme(); });
      resetTheme3Btn.addEventListener('click', ()=> { theme3 = '#0b2233'; theme3Input.value = theme3; localStorage.setItem('notcord_theme3', theme3); applyTheme(); });

      // Utility functions reused here
      function fileToDataUrl(file){ return new Promise((res, rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); }); }
      function isGif(file){ return file.type === 'image/gif' || /\.gif$/i.test(file.name); }
      function resizeImageDataUrl(dataUrl, maxW=1024, maxH=768){ return new Promise((res, rej)=>{ const img = new Image(); img.onload = ()=>{ let w=img.width,h=img.height; if(w<=maxW && h<=maxH) return res(dataUrl); const ratio=Math.min(maxW/w,maxH/h); const canvas=document.createElement('canvas'); canvas.width=Math.round(w*ratio); canvas.height=Math.round(h*ratio); canvas.getContext('2d').drawImage(img,0,0,canvas.width,canvas.height); res(canvas.toDataURL('image/jpeg',0.85)); }; img.onerror=rej; img.src=dataUrl; }); }

      // Initialization sequence
      (async function init(){
        refreshPinnedUI();
        setActiveChannelUI(activeChannel);
        await initUserFromServer().catch(()=>{});
        initSocket();
        if(currentUser && socket) socket.emit('join', { channel: activeChannel });
        if('Notification' in window && Notification.permission === 'default'){ try{ await Notification.requestPermission(); }catch(e){} }
        await fetchMessages().catch(()=>{});
        await fetchPlayers().catch(()=>{});
        updateCharCount();
        // presence: notify server when page hidden/visible
        document.addEventListener('visibilitychange', ()=> { if(socket) socket.emit('visibility', { idle: document.hidden }); setTimeout(()=>fetchPlayers().catch(()=>{}),200); });
      })();

      // Expose for debugging
      window._notcord = { clientToken, currentUser: ()=> currentUser, fetchMessages, fetchPlayers, pinnedMessages };

    })();
  </script>
</body>
</html>
