<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>notcord ‚Äî multi-channel (updated)</title>
  <style>
    :root{
      --theme-1: #071226;
      --theme-2: #07101a;
      --theme-3: #0b2233;    /* chat bubbles & logo */ 
      --muted: #9aa4b2;
      --accent: #5865f2;
      --me-bg: #2b3440;
      --border: rgba(255,255,255,0.06);
      --text: #e6eef6;
      --idle-yellow: #f0c419;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Helvetica,Arial;color:var(--text);
      background:linear-gradient(180deg,var(--theme-1) 0%, var(--theme-2) 100%);
    }
    .app { width:100%; height:100vh; display:grid; grid-template-columns:260px 1fr 260px; overflow:hidden; gap:0 }
    .sidebar{ padding:14px; display:flex; flex-direction:column; gap:12px; height:100vh; overflow:auto; background:linear-gradient(180deg,var(--theme-1),var(--theme-2)); border-right:1px solid var(--border) }
    .brand{display:flex;gap:10px;align-items:center;font-weight:700;font-size:18px}
    .brand .dot{width:18px;height:18px;border-radius:50%;background:var(--theme-2);box-shadow:0 6px 20px rgba(11,34,51,0.35)}
    .brand .name{color:var(--theme-3);font-weight:800;font-size:18px}
    .usernameBox{display:flex;gap:8px;align-items:center}
    .usernameBox input{flex:1;padding:8px;background:transparent;border:1px solid var(--border);border-radius:8px;color:inherit;outline:none}
    .usernameBox button{padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer}
    .usernameLocked{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid var(--border);font-weight:600;overflow:hidden}
    .usernameLocked .avatar{width:28px;height:28px;border-radius:6px;object-fit:cover;background:rgba(255,255,255,0.03)}
    .channels{margin-top:6px;display:flex;flex-direction:column;gap:6px}
    .channel{padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer;border:1px solid transparent;display:flex;justify-content:space-between;align-items:center}
    .channel:hover{background:rgba(255,255,255,0.01)}
    .channel.active{background:linear-gradient(90deg, rgba(88,101,242,0.12), rgba(88,101,242,0.02));color:var(--text);border-color:rgba(88,101,242,0.12)}
    .settings{margin-top:auto;display:flex;flex-direction:column;gap:8px;padding-top:8px;border-top:1px solid var(--border)}
    .settings label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px}
    .settings input[type="color"]{width:48px;height:32px;padding:0;border:none;background:transparent;cursor:pointer}
    .settings .toggleBtn{padding:8px;border-radius:8px;background:transparent;border:1px solid var(--border);color:var(--muted);cursor:pointer}
    .chatPanel{display:flex;flex-direction:column;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);position:relative;min-height:0}
    .chatBox{display:flex;flex-direction:column;height:100%;min-height:0}
    .header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px;background:transparent}
    .header h2{margin:0;font-size:18px;display:flex;gap:8px;align-items:center}
    .spacer{flex:1}
    .right{display:flex;flex-direction:column;align-items:flex-end;gap:2px}
    .status{color:var(--muted);font-size:13px}
    .typing{color:var(--muted);font-size:12px;height:18px}
    .messages{flex:1;overflow:auto;padding:20px;display:flex;flex-direction:column;gap:12px;scroll-behavior:smooth;min-height:0;background:transparent}
    .message{display:flex;gap:12px;align-items:flex-start;max-width:85%}
    .message.me{margin-left:auto;justify-content:flex-end}
    .authorAvatar{width:36px;height:36px;border-radius:8px;object-fit:cover;background:rgba(255,255,255,0.02);flex-shrink:0}
    .bubble{
      background:var(--theme-3);
      color:var(--text);
      padding:10px 12px;border-radius:12px;display:flex;flex-direction:column;gap:6px;word-break:break-word;
      border-left:4px solid rgba(0,0,0,0.08);
      box-shadow:0 6px 18px rgba(2,6,23,0.6);
      max-width:520px;
    }
    .message.me .bubble{
      background:var(--theme-3);
      border-left-color: var(--accent);
      transform: translateY(0);
    }
    .replyBtn {
      margin-left: 8px;
      font-size: 12px;
      color: var(--muted);
      background: transparent;
      border: none;
      cursor: pointer;
    }
    .replyBtn:hover { text-decoration: underline; }
    .replyTag {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
      padding-left:6px;
      border-left:2px solid rgba(255,255,255,0.03);
    }
    .meta{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
    .meta .name{font-weight:700}
    .meta .time{font-size:12px;color:var(--muted)}
    .text{white-space:pre-wrap;color:inherit;font-size:15px;word-break:break-word;overflow-wrap:break-word}
    .privateTag{font-size:12px;color:#ffd980;margin-left:8px}
    .photoMessage img { max-width: 420px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); cursor:pointer; transition:transform .15s; display:block; max-height:480px; width:auto }
    .photoMessage img:hover{ transform: scale(1.03) }
    .inputArea{padding:12px;border-top:1px solid var(--border);display:flex;gap:8px;align-items:flex-end;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
    .inputArea textarea{flex:1;min-height:44px;max-height:160px;resize:none;padding:10px;border-radius:10px;background:transparent;border:1px solid var(--border);color:inherit;outline:none}
    .controls{display:flex;flex-direction:column;align-items:flex-end;gap:6px;min-width:120px}
    .charCount{font-size:12px;color:var(--muted)}
    .sendBtn{background:var(--accent);border:none;color:white;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600}
    .sendBtn:disabled{opacity:0.6;cursor:default}
    .photoUploadArea { padding:12px; border-top:1px solid var(--border); display:flex; gap:8px; align-items:center; background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent) }
    .photoUploadArea input[type=file]{ flex:1 }
    .photoUploadArea button{ background:var(--accent); color:white; border:none; padding:8px 12px; border-radius:10px; cursor:pointer }
    .playersPanel{background:linear-gradient(180deg,var(--theme-1),var(--theme-2));border-left:1px solid var(--border);padding:14px;display:flex;flex-direction:column;gap:12px;height:100vh;overflow:auto}
    .playersPanel h3{margin:0;font-size:15px;color:var(--muted)}
    .playersList{display:flex;flex-direction:column;gap:6px;overflow:auto}
    .player{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid transparent;color:var(--text)}
    .player.offline{opacity:0.6}
    .player .statusDot{width:10px;height:10px;border-radius:50%;margin-right:8px;flex-shrink:0}
    .player.online .statusDot{background:#39d353;box-shadow:0 0 8px rgba(57,211,83,0.12)}
    .player.offline .statusDot{background:#a0a0a0}
    .pinnedSection{padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid var(--border);font-size:13px}
    .pinnedItem{padding:6px;border-radius:6px;background:rgba(255,255,255,0.01);display:flex;gap:8px;align-items:center}
    .idleDot{width:10px;height:10px;border-radius:50%;background:var(--idle-yellow);box-shadow:0 0 8px rgba(240,196,25,0.12)}
    @media (max-width:980px){ .app{grid-template-columns:200px 1fr 140px} }
    @media (max-width:720px){ .app{grid-template-columns:1fr} .sidebar,.playersPanel{display:none} }
  </style>
</head>
<body>
  <div class="app" id="app">
    <aside class="sidebar" id="sidebar">
      <div class="brand"><div class="dot" aria-hidden></div><div class="name">notcord</div></div>

      <div id="usernameSection">
        <div class="usernameBox" id="usernameBox">
          <input type="text" id="usernameInput" placeholder="Choose username (max 8 chars)" maxlength="8" />
          <button id="setNameBtn">Set</button>
        </div>
        <div class="usernameLocked" id="usernameLocked" style="display:none">
          <img src="" id="userAvatarSmall" class="avatar" alt="avatar" />
          <div id="usernameDisplay"></div>
        </div>

        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <label style="font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px">Change avatar (weekly)
            <input type="file" id="avatarInput" accept="image/*" />
          </label>
          <button id="changeNameBtn" class="toggleBtn" title="Change name (weekly)" style="padding:8px 10px">Change Name</button>
        </div>
        <div id="nameChangeInfo" style="font-size:12px;color:var(--muted);margin-top:4px"></div>
      </div>

      <div class="channels" id="channels">
        <div class="channel active" data-id="general" role="button"># general</div>
        <div class="channel" data-id="photos" role="button"># photos</div>
        <!-- # announcements and # general 2 removed as requested -->
      </div>

      <div class="pinnedSection" id="pinnedSection" style="display:none">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Pinned</div>
          <div style="font-size:12px;color:var(--muted)"><button id="clearPins" class="toggleBtn" style="padding:4px 6px">Clear</button></div>
        </div>
        <div id="pinnedList" style="margin-top:8px;display:flex;flex-direction:column;gap:6px"></div>
      </div>

      <div class="settings" aria-label="Appearance settings">
        <label>Your name color
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="nameColor" title="Name color" />
            <div style="flex:1"></div>
            <button id="resetNameColor" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>Theme color 1
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor1" title="Theme color 1" />
            <div style="flex:1"></div>
            <button id="resetTheme1" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>Theme color 2
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor2" title="Theme color 2" />
            <div style="flex:1"></div>
            <button id="resetTheme2" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>Theme color 3 (chat bubbles & logo)
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor3" title="Theme color 3" />
            <div style="flex:1"></div>
            <button id="resetTheme3" class="toggleBtn">Reset</button>
          </div>
        </label>

        <div style="font-size:12px;color:var(--muted);padding-top:6px">
          Username, avatar and appearance saved in browser.<br/>Use "/w name text" to send a private message. Mention with @name to ping.
        </div>
      </div>
    </aside>

    <section class="chatPanel">
      <div class="chatBox" id="chatBox">
        <div class="header">
          <h2 id="channelTitle"># general</h2>
          <div class="spacer"></div>
          <div class="right">
            <div id="status" class="status">Connecting...</div>
            <div id="typingIndicator" class="typing"></div>
          </div>
        </div>

        <div class="messages" id="messages" role="log" aria-atomic="false"></div>

        <div class="inputArea" id="inputWrapper">
          <textarea id="messageInput" placeholder="Message (Shift+Enter for newline)" maxlength="100"></textarea>
          <div class="controls">
            <div class="charCount" id="charCount">0 / 100</div>
            <button id="sendBtn" class="sendBtn" disabled>Send</button>
          </div>
        </div>

        <div class="photoUploadArea" id="photoUploadWrapper" style="display:none">
          <input type="file" id="photoInput" accept="image/*,image/gif" />
          <button id="uploadPhotoBtn" disabled>Upload Photo / GIF</button>
        </div>
      </div>
    </section>

    <aside class="playersPanel" id="playersPanel">
      <h3>Players</h3>
      <div id="playersStatus" style="font-size:13px;color:var(--muted)">Loading...</div>
      <div style="height:6px"></div>
      <div class="playersList" id="playersList" aria-live="polite"></div>
    </aside>
  </div>

  <script>
    (function(){
      /***** Config & endpoints *****/
      const CHANNELS = {
        general: 'https://68e839b2f2707e6128ca35e1.mockapi.io/chat',
        photos: 'https://68eeed86b06cc802829ba196.mockapi.io/photos'
      };
      const PLAYERS_API = 'https://68e839b2f2707e6128ca35e1.mockapi.io/players';
      const BAD_WORDS = ['fuck','bitch','nigger','tun tun tun sahur','–Ω–∞—Ö—É–π','–≥–µ–π','gay','—Ö—É–µ—Ç–∞'];

      /***** UI refs *****/
      const channelsEl = document.getElementById('channels');
      const channelTitleEl = document.getElementById('channelTitle');
      const messagesEl = document.getElementById('messages');
      const statusEl = document.getElementById('status');
      const typingIndicatorEl = document.getElementById('typingIndicator');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const charCountEl = document.getElementById('charCount');
      const inputWrapper = document.getElementById('inputWrapper');
      const photoUploadWrapper = document.getElementById('photoUploadWrapper');
      const photoInput = document.getElementById('photoInput');
      const uploadPhotoBtn = document.getElementById('uploadPhotoBtn');

      const usernameBox = document.getElementById('usernameBox');
      const usernameInput = document.getElementById('usernameInput');
      const setNameBtn = document.getElementById('setNameBtn');
      const usernameLocked = document.getElementById('usernameLocked');
      const usernameDisplay = document.getElementById('usernameDisplay');
      const userAvatarSmall = document.getElementById('userAvatarSmall');
      const avatarInput = document.getElementById('avatarInput');
      const changeNameBtn = document.getElementById('changeNameBtn');
      const nameChangeInfo = document.getElementById('nameChangeInfo');

      const nameColorInput = document.getElementById('nameColor');
      const themeColor1Input = document.getElementById('themeColor1');
      const themeColor2Input = document.getElementById('themeColor2');
      const themeColor3Input = document.getElementById('themeColor3');
      const resetNameColorBtn = document.getElementById('resetNameColor');
      const resetTheme1Btn = document.getElementById('resetTheme1');
      const resetTheme2Btn = document.getElementById('resetTheme2');
      const resetTheme3Btn = document.getElementById('resetTheme3');

      const playersListEl = document.getElementById('playersList');
      const playersStatusEl = document.getElementById('playersStatus');

      const pinnedSection = document.getElementById('pinnedSection');
      const pinnedList = document.getElementById('pinnedList');
      const clearPinsBtn = document.getElementById('clearPins');

      /***** State *****/
      let activeChannel = localStorage.getItem('notcord_channel') || 'general';
      let apiBase = CHANNELS[activeChannel] || null;
      let polling = null;
      let playersPolling = null;
      let heartbeatInterval = null;
      let isSending = false;
      const MAX_CHARS = 100;
      const TYPING_KEY = 'notcord_typing_v3';
      const TYPING_EXPIRE_MS = 5000;
      const HEARTBEAT_MS = 5000;
      const PLAYER_OFFLINE_THRESHOLD_MS = 15000;

      // user
      let username = localStorage.getItem('notcord_username') || '';
      let nameColor = localStorage.getItem('notcord_nameColor') || '#ffcc00';
      let themeColor1 = localStorage.getItem('notcord_theme1') || '#071226';
      let themeColor2 = localStorage.getItem('notcord_theme2') || '#07101a';
      let themeColor3 = localStorage.getItem('notcord_theme3') || '#0b2233';
      let accentColor = localStorage.getItem('notcord_accent') || themeColor1;
      let localPlayerId = localStorage.getItem('notcord_playerId') || null;
      let avatarDataUrl = localStorage.getItem('notcord_avatar') || ''; // small base64 url
      let pinnedMessages = JSON.parse(localStorage.getItem('notcord_pins') || '[]');

      // name/avatar change restrictions (weekly)
      const NAME_CHANGE_KEY = 'notcord_name_change_ts';
      const AVATAR_CHANGE_KEY = 'notcord_avatar_change_ts';
      const NAME_MAX_LENGTH = 8;
      const WEEK_MS = 7*24*60*60*1000;

      /***** Utils *****/
      function setStatus(txt){ statusEl.textContent = txt; }
      function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
      function formatTime(iso){ try{ const d=new Date(iso); if(isNaN(d)) return ''; return d.toLocaleString([], {hour:'2-digit', minute:'2-digit'}); }catch(e){return ''} }
      function now(){ return Date.now(); }

      /***** Theme & appearance *****/
      function applyTheme(){ document.documentElement.style.setProperty('--theme-1', themeColor1); document.documentElement.style.setProperty('--theme-2', themeColor2); document.documentElement.style.setProperty('--theme-3', themeColor3); document.documentElement.style.setProperty('--accent', accentColor || themeColor1); /* brand dot is using theme-2 by CSS already */ }
      function initializeAppearanceInputs(){ nameColorInput.value = nameColor; themeColor1Input.value = themeColor1; themeColor2Input.value = themeColor2; themeColor3Input.value = themeColor3; }

      /***** Typing indicator (localStorage) *****/
      function readTypingMap(){ try{ return JSON.parse(localStorage.getItem(TYPING_KEY)||'{}'); }catch(e){ return {}; } }
      function writeTypingMap(m){ try{ localStorage.setItem(TYPING_KEY, JSON.stringify(m)); }catch(e){} }
      function updateTypingUI(){
        const map = readTypingMap();
        const channelMap = map[activeChannel] || {};
        const nowTs = now();
        const typers = Object.keys(channelMap).filter(u => u !== username && (nowTs - channelMap[u]) <= TYPING_EXPIRE_MS);
        if(!typers.length) typingIndicatorEl.textContent = '';
        else if(typers.length === 1) typingIndicatorEl.textContent = typers[0] + ' is typing...';
        else typingIndicatorEl.textContent = typers[0] + ' and ' + (typers.length-1) + ' others are typing...';
      }
      window.addEventListener('storage', (e)=> { if(e.key === TYPING_KEY) updateTypingUI(); });

      /***** Helpers *****/
      function isUserMuted(user){
        const t = muteMap.get(user);
        if(!t) return false;
        if(Date.now() > t){ muteMap.delete(user); return false; }
        return true;
      }
      function muteUser(user, seconds=120){ muteMap.set(user, Date.now() + seconds*1000); }

      function containsBadWords(text){
        if(!text) return false;
        const lower = text.toLowerCase();
        return BAD_WORDS.some(w => w && lower.includes(w));
      }

      /***** Message rendering (with avatar, reply, pinned marker, highlight mentions) *****/
      function renderMessage(msg, localUser){
        // handle private
        if(msg.privateTo && !(msg.privateTo === localUser || msg.username === localUser)) return null;

        const container = document.createElement('div');
        const author = msg.username || msg.name || 'Unknown';
        const isMe = author === localUser;
        container.className = 'message' + (isMe ? ' me' : '');

        const avatarImg = document.createElement('img');
        avatarImg.className = 'authorAvatar';
        avatarImg.alt = author + ' avatar';
        // choose avatar priority: msg.avatar -> local storage mapping -> default
        if(msg.avatar) avatarImg.src = msg.avatar;
        else if(author === username && avatarDataUrl) avatarImg.src = avatarDataUrl;
        else avatarImg.src = ''; // will appear as background

        const bubble = document.createElement('div'); bubble.className = 'bubble';

        // meta row
        const meta = document.createElement('div'); meta.className = 'meta';
        const nameEl = document.createElement('span'); nameEl.className = 'name'; nameEl.textContent = author;
        if(msg.nameColor) nameEl.style.color = msg.nameColor;
        else if(isMe && nameColor) nameEl.style.color = nameColor;
        const timeEl = document.createElement('span'); timeEl.className = 'time'; timeEl.textContent = formatTime(msg.createdAt || msg.created_at || msg.timestamp || msg.time || '');

        meta.appendChild(nameEl);
        meta.appendChild(timeEl);

        // reply button for messages not mine and not private
        if (!isMe && !msg.privateTo) {
          const replyBtn = document.createElement('button');
          replyBtn.className = 'replyBtn';
          replyBtn.textContent = 'Reply';
          replyBtn.onclick = (e) => { e.stopPropagation(); setReplyTo(msg); };
          meta.appendChild(replyBtn);
        }

        bubble.appendChild(meta);

        // show quoted reply preview (if msg.replyToObj present or replyTo text)
        if(msg.replyToObj){
          const r = document.createElement('div');
          r.className = 'replyTag';
          r.textContent = `${msg.replyToObj.username || msg.replyToObj.name || 'Unknown'}: ${truncateText(msg.replyToObj.message || msg.replyToObj.text || msg.replyToObj.content || '', 140)}`;
          bubble.appendChild(r);
        } else if(msg.replyTo){
          const r = document.createElement('div');
          r.className = 'replyTag';
          r.textContent = `Replying to ${msg.replyTo}`;
          bubble.appendChild(r);
        }

        // content (image or text)
        if(msg.imageUrl){
          const photoDiv = document.createElement('div'); photoDiv.className = 'photoMessage';
          const img = document.createElement('img'); img.src = msg.imageUrl; img.alt = msg.message || 'photo';
          img.addEventListener('click', ()=> window.open(img.src, '_blank'));
          photoDiv.appendChild(img);
          if(msg.message){
            const caption = document.createElement('div'); caption.className = 'text'; caption.textContent = msg.message;
            photoDiv.appendChild(caption);
          }
          bubble.appendChild(photoDiv);
        } else {
          const text = document.createElement('div'); text.className = 'text';
          const content = msg.message || msg.text || msg.content || '';
          // highlight mentions of current user
          if(username && content.includes('@'+username)){
            const parts = content.split(new RegExp('(@'+username+')','g'));
            parts.forEach(p=>{
              if(p === '@'+username){
                const span = document.createElement('span');
                span.textContent = p;
                span.style.background = 'rgba(240,196,25,0.12)';
                span.style.color = 'var(--idle-yellow)';
                span.style.padding = '2px 4px';
                span.style.borderRadius = '4px';
                text.appendChild(span);
              } else {
                text.appendChild(document.createTextNode(p));
              }
            });
          } else {
            text.textContent = content;
          }
          bubble.appendChild(text);
        }

        // pinned marker
        if(isMessagePinned(msg)){
          const p = document.createElement('div');
          p.style.fontSize = '12px'; p.style.color = 'var(--muted)'; p.textContent = 'üìå Pinned';
          bubble.appendChild(p);
        }

        // container layout: avatar + bubble
        const wrapper = document.createElement('div');
        wrapper.style.display = 'flex';
        wrapper.style.gap = '12px';
        if(container.className.includes('me')){
          // for own messages put bubble then avatar
          wrapper.appendChild(bubble);
          wrapper.appendChild(avatarImg);
        } else {
          wrapper.appendChild(avatarImg);
          wrapper.appendChild(bubble);
        }
        container.appendChild(wrapper);

        // clicking on mention plays simple visual ping (here: brief flash)
        if(username && (msg.message||'').includes('@'+username)){
          container.style.boxShadow = '0 0 0 rgba(88,101,242,0.0)';
          setTimeout(()=> container.style.boxShadow = '', 2500);
          // also update status text briefly
          setStatus('You were mentioned by '+author);
        }

        // attach message id for later reply lookup
        container.dataset.msgId = msg.id || '';

        return container;
      }

      function truncateText(s, n){ if(!s) return ''; return s.length>n ? s.slice(0,n-1)+'‚Ä¶' : s; }

      function isAtBottom(){ return messagesEl.scrollTop + messagesEl.clientHeight >= messagesEl.scrollHeight - 80; }
      function scrollToBottom(){ requestAnimationFrame(()=> messagesEl.scrollTop = messagesEl.scrollHeight); }

      /***** Fetch & post messages (with trimming & reply attachments) *****/
      async function fetchMessages(){
        if(!apiBase) return;
        try{
          const res = await fetch(apiBase);
          if(!res.ok) throw new Error('Fetch failed: '+res.status);
          let data = await res.json();
          if(!Array.isArray(data)) return;

          data.sort((a,b)=> {
            const ta = new Date(a.createdAt||a.created_at||a.timestamp||0).getTime() || (Number(a.id)||0);
            const tb = new Date(b.createdAt||b.created_at||b.timestamp||0).getTime() || (Number(b.id)||0);
            return ta-tb;
          });

          // Trim messages if over 80 (delete older ones)
          if(data.length > 80){
            const toDelete = data.slice(0, data.length - 40);
            for(const msg of toDelete){
              if(msg.id){
                fetch(`${apiBase}/${msg.id}`, { method:'DELETE' }).catch(()=>{});
              }
            }
          }

          // build lookup for replies: some messages may contain replyToId
          const lookup = {};
          for(const m of data) lookup[m.id] = m;

          const wasAtBottom = isAtBottom();
          messagesEl.innerHTML = '';
          for(const m of data){
            // if message references replyToId, attach replyToObj for preview
            if(m.replyToId && lookup[m.replyToId]) m.replyToObj = { username: lookup[m.replyToId].username || lookup[m.replyToId].name, message: lookup[m.replyToId].message || lookup[m.replyToId].text };
            const el = renderMessage(m, username);
            if(el) messagesEl.appendChild(el);
          }
          if(wasAtBottom) scrollToBottom();
          setStatus('Connected ‚Äî '+data.length+' messages');
        }catch(e){ console.error(e); setStatus('Error fetching messages'); }
      }

      async function safeFetch(url, method='GET', body=null){
        try{
          const opts = { method, headers:{} };
          if(body !== null){ opts.headers['Content-Type']='application/json'; opts.body = JSON.stringify(body); }
          const r = await fetch(url, opts);
          if(!r.ok) return null;
          if(r.status === 204) return null;
          return await r.json();
        }catch(e){ console.warn('safeFetch', e); return null; }
      }

      // optimistic post with mention detection & reply linking
      async function postMessage(rawText){
        if(!rawText || !rawText.trim()) return;
        if(!username){ setStatus('Set username first'); return; }
        if(isUserMuted(username)){ const rem = Math.ceil((muteMap.get(username)-Date.now())/1000); setStatus('You are muted. Remaining: '+rem+'s'); return; }
        if(!apiBase){ setStatus('No channel selected'); return; }
        if(containsBadWords(rawText)){ muteUser(username, 120); setStatus('Forbidden words detected. You are muted for 2 minutes.'); return; }

        isSending = true;
        sendBtn.disabled = true;

        let privateTo = null;
        let messageText = rawText.trim();
        if(messageText.toLowerCase().startsWith('/w ')){
          const m = messageText.match(/^\/w\s+(\S+)\s+([\s\S]+)$/i);
          if(m){ privateTo = m[1]; messageText = m[2]; if(!messageText){ setStatus('Whisper requires text'); isSending=false; sendBtn.disabled=false; return; } }
          else { setStatus('Whisper format: /w name text'); isSending=false; sendBtn.disabled=false; return; }
        }

        // detect mentions for simple ping UX (server notifies not implemented, local UI only)
        const mentions = (messageText.match(/@\w+/g) || []).map(m=>m.slice(1));

        const payload = { username, message: messageText, createdAt: new Date().toISOString(), nameColor, privateTo: privateTo || null, isPrivate: !!privateTo };

        // include replyToId if a reply target exists
        if(replyToMessage && replyToMessage.id) payload.replyToId = replyToMessage.id;

        const optimistic = renderMessage(payload, username);
        if(optimistic) messagesEl.appendChild(optimistic);
        scrollToBottom();

        try{
          const res = await fetch(apiBase, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          if(!res.ok) throw new Error('Send failed: '+res.status);
          await fetchMessages();
        }catch(e){ console.error(e); setStatus('Failed to send'); }
        finally{ isSending = false; sendBtn.disabled = false; }
      }

      /***** Image resizing & GIF handling for upload *****/
      function isGif(file){ return file.type === 'image/gif' || /\.gif$/i.test(file.name); }
      async function fileToDataUrl(file){
        return new Promise((res, rej)=>{
          const r = new FileReader();
          r.onload = ()=> res(r.result);
          r.onerror = rej;
          r.readAsDataURL(file);
        });
      }
      async function resizeImageFileIfNeeded(file, maxWidth=420, maxHeight=480){
        if(isGif(file)) {
          // return as-is for GIFs (we allow GIFs). But large GIFs may be huge - user will upload as-is.
          return fileToDataUrl(file);
        }
        const url = await fileToDataUrl(file);
        const img = new Image();
        return new Promise((resolve, reject)=>{
          img.onload = ()=>{
            let { width, height } = img;
            if(width <= maxWidth && height <= maxHeight){
              resolve(url); // no resize needed
              return;
            }
            const ratio = Math.min(maxWidth/width, maxHeight/height);
            const canvas = document.createElement('canvas');
            canvas.width = Math.round(width*ratio);
            canvas.height = Math.round(height*ratio);
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            const resized = canvas.toDataURL('image/jpeg', 0.85);
            resolve(resized);
          };
          img.onerror = reject;
          img.src = url;
        });
      }

      async function uploadPhoto(file){
        if(!file) return;
        if(!username){ setStatus('Set username first'); return; }
        if(isUserMuted(username)){ setStatus('You are muted and cannot upload'); return; }
        if(containsBadWords(file.name)){ muteUser(username, 120); setStatus('Forbidden file name. You are muted for 2 minutes.'); return; }

        isSending = true;
        uploadPhotoBtn.disabled = true;
        try{
          const dataUrl = await resizeImageFileIfNeeded(file); // handles GIFs & resize
          const payload = { username, createdAt: new Date().toISOString(), nameColor, imageUrl: dataUrl, message: '' };
          const res = await fetch(CHANNELS.photos, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          if(!res.ok) throw new Error('Upload failed: '+res.status);
          setStatus('Photo uploaded');
          photoInput.value = '';
          await fetchMessages();
        }catch(e){ console.error(e); setStatus('Photo upload failed'); }
        finally{ isSending = false; uploadPhotoBtn.disabled = false; }
      }

      /***** Players / online detection (idle yellow dot when user computer on but not on site) *****/
      function normalizePlayerName(p){ return p.name || p.username || p.nick || p.displayName || (p.id?String(p.id):String(p)); }
      function detectPlayerOnline(p){ try{ if(p.lastSeen){ const last = Date.parse(p.lastSeen); if(!isNaN(last) && (Date.now() - last) <= PLAYER_OFFLINE_THRESHOLD_MS) return true; } }catch(e){} return false; }

      async function fetchPlayers(){
        try{
          const res = await fetch(PLAYERS_API);
          if(!res.ok) throw new Error('Players fetch failed: '+res.status);
          const data = await res.json();
          if(!Array.isArray(data)){ playersStatusEl.textContent='No players'; playersListEl.innerHTML=''; return; }
          const online = [], offline = [];
          for(const p of data){
            const name = normalizePlayerName(p);
            const on = detectPlayerOnline(p);
            if(on) online.push({name, raw:p});
            else offline.push({name, raw:p});
          }
          // ensure local user present
          if(username){
            const existsOnline = online.some(x=>x.name===username);
            const existsOffline = offline.some(x=>x.name===username);
            if(!existsOnline && !existsOffline) online.unshift({ name:username, raw:{ name:username, lastSeen:new Date().toISOString(), nameColor } , local:true });
          }

          playersListEl.innerHTML = '';
          const headerOnline = document.createElement('div'); headerOnline.style.color='var(--muted)'; headerOnline.style.fontSize='13px'; headerOnline.textContent = 'Online ('+online.length+')';
          playersListEl.appendChild(headerOnline);
          for(const p of online){
            const item = document.createElement('div'); item.className='player online';
            const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
            const dot = document.createElement('span'); dot.className='statusDot';
            const nameSpan = document.createElement('div'); nameSpan.className='playerName';
            nameSpan.innerHTML = escapeHtml(p.name) + (p.local ? ' <span style="font-size:12px;color:var(--muted)">(you)</span>' : '');
            const serverColor = (p.raw && (p.raw.nameColor || p.raw.color)) ? (p.raw.nameColor || p.raw.color) : null;
            if(serverColor) nameSpan.style.color = serverColor;
            else if(p.local && nameColor) nameSpan.style.color = nameColor;
            left.appendChild(dot); left.appendChild(nameSpan);
            const right = document.createElement('div'); right.style.fontSize='12px'; right.style.color='var(--muted)'; right.textContent='online';
            item.appendChild(left); item.appendChild(right);
            playersListEl.appendChild(item);
          }

          const spacer = document.createElement('div'); spacer.style.height='8px'; playersListEl.appendChild(spacer);

          const headerOff = document.createElement('div'); headerOff.style.color='var(--muted)'; headerOff.style.fontSize='13px'; headerOff.textContent = 'Offline ('+offline.length+')';
          playersListEl.appendChild(headerOff);
          for(const p of offline){
            const item = document.createElement('div'); item.className='player offline';
            const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
            const dot = document.createElement('span'); dot.className='statusDot';
            const nameSpan = document.createElement('div'); nameSpan.className='playerName'; nameSpan.textContent = p.name;
            const serverColor = (p.raw && (p.raw.nameColor || p.raw.color)) ? (p.raw.nameColor || p.raw.color) : null;
            if(serverColor) nameSpan.style.color = serverColor;
            left.appendChild(dot); left.appendChild(nameSpan);
            const right = document.createElement('div'); right.style.fontSize='12px'; right.style.color='var(--muted)'; right.textContent='offline';
            item.appendChild(left); item.appendChild(right);
            playersListEl.appendChild(item);
          }
          playersStatusEl.textContent = 'Updated: ' + new Date().toLocaleTimeString();
        }catch(e){ console.error(e); playersStatusEl.textContent='Error loading players'; playersListEl.innerHTML=''; }
      }

      async function upsertLocalPlayer(){
        if(!username) return;
        try{
          const res = await fetch(PLAYERS_API);
          if(!res.ok) throw new Error('Players fetch failed: '+res.status);
          const data = await res.json();
          if(!Array.isArray(data)) return;
          const found = data.find(p => normalizePlayerName(p) === username);
          const nowTs = new Date().toISOString();
          if(found){
            localPlayerId = found.id;
            localStorage.setItem('notcord_playerId', localPlayerId);
            await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', {...found, name: username, lastSeen: nowTs, nameColor, avatar: avatarDataUrl});
          } else {
            const created = await safeFetch(PLAYERS_API, 'POST', { name: username, lastSeen: nowTs, nameColor, avatar: avatarDataUrl });
            if(created && created.id){ localPlayerId = created.id; localStorage.setItem('notcord_playerId', localPlayerId); }
          }
        }catch(e){ console.warn('upsertLocalPlayer', e); } finally{ fetchPlayers().catch(()=>{}); }
      }

      async function setLocalPlayerOnlineState(isOnline){
        if(!localPlayerId) return;
        try{
          const cur = await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'GET', null);
          if(!cur) return;
          const updated = { ...cur, online: !!isOnline, lastSeen: new Date().toISOString(), name: username || cur.name, nameColor: nameColor || cur.nameColor, avatar: avatarDataUrl || cur.avatar };
          await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', updated);
        }catch(e){ console.warn('setLocalPlayerOnlineState', e); } finally{ fetchPlayers().catch(()=>{}); }
      }

      /***** Message trimming already included in fetchMessages (keeps it summarized) *****/

      /***** Heartbeat *****/
      function startHeartbeat(){
        stopHeartbeat();
        if(!username || !localPlayerId) return;
        heartbeatInterval = setInterval(async ()=>{
          try{ await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', { lastSeen: new Date().toISOString(), online:true, name: username, nameColor, avatar: avatarDataUrl }); }catch(e){ console.warn('heartbeat', e); }
        }, HEARTBEAT_MS);
      }
      function stopHeartbeat(){ if(heartbeatInterval){ clearInterval(heartbeatInterval); heartbeatInterval = null; } }

      /***** Input & character state *****/
      function updateCharCountAndState(){
        let val = messageInput.value || '';
        if(val.length > MAX_CHARS) messageInput.value = val.slice(0, MAX_CHARS);
        charCountEl.textContent = `${(messageInput.value||'').length} / ${MAX_CHARS}`;
        const canSend = username && (messageInput.value||'').trim().length > 0 && activeChannel !== 'photos' && !isSending && !isUserMuted(username);
        sendBtn.disabled = !canSend;
      }

      function updateInputArea(){
        if(activeChannel === 'photos'){
          inputWrapper.style.display = 'none';
          photoUploadWrapper.style.display = 'flex';
          uploadPhotoBtn.disabled = true;
        } else {
          photoUploadWrapper.style.display = 'none';
          inputWrapper.style.display = 'flex';
        }
      }

      /***** Prevent accidental close (keeps earlier behavior) *****/
      let backslashPressed = false;
      window.addEventListener('keydown', (e) => { if (e.key === '\\') backslashPressed = true; });
      window.addEventListener('beforeunload', (e) => { if (!backslashPressed) { e.preventDefault(); e.returnValue = ''; return ''; } });

      /***** Reply functionality: show quoted message and ESC to clear *****/
      let replyToMessage = null;
      function setReplyTo(messageObj){
        replyToMessage = messageObj;
        const name = messageObj.username || messageObj.name || 'Unknown';
        const txt = messageObj.message || messageObj.text || messageObj.content || '';
        messageInput.placeholder = `Replying to ${name}: "${truncateText(txt, 60)}" (Esc to cancel)`;
        messageInput.focus();
      }
      function clearReplyTo(){
        replyToMessage = null;
        messageInput.placeholder = 'Message (Shift+Enter for newline)';
      }
      document.addEventListener('keydown', (e)=>{
        if(e.key === 'Escape'){ clearReplyTo(); }
      });

      /***** Pinned messages UI & storage *****/
      function isMessagePinned(msg){
        if(!msg || !msg.id) return false;
        return pinnedMessages.includes(String(msg.id));
      }
      function refreshPinnedUI(){
        if(pinnedMessages.length === 0){ pinnedSection.style.display='none'; pinnedList.innerHTML=''; return; }
        pinnedSection.style.display='block';
        pinnedList.innerHTML = '';
        pinnedMessages.forEach(id=>{
          const item = document.createElement('div'); item.className = 'pinnedItem';
          item.textContent = `Message ID: ${id}`;
          const btn = document.createElement('button'); btn.textContent = 'Unpin'; btn.style.marginLeft='auto';
          btn.className = 'toggleBtn';
          btn.onclick = ()=> { pinnedMessages = pinnedMessages.filter(x=>x!==id); localStorage.setItem('notcord_pins', JSON.stringify(pinnedMessages)); refreshPinnedUI(); fetchMessages().catch(()=>{}); };
          item.appendChild(btn);
          pinnedList.appendChild(item);
        });
      }
      clearPinsBtn.addEventListener('click', ()=>{ pinnedMessages = []; localStorage.setItem('notcord_pins', JSON.stringify(pinnedMessages)); refreshPinnedUI(); });

      // Right-click on message to pin/unpin
      messagesEl.addEventListener('contextmenu', (e)=>{
        const msgEl = e.target.closest('.message');
        if(!msgEl) return;
        e.preventDefault();
        const msgId = msgEl.dataset.msgId;
        if(!msgId) return;
        if(pinnedMessages.includes(msgId)) pinnedMessages = pinnedMessages.filter(x=>x!==msgId);
        else pinnedMessages.push(msgId);
        localStorage.setItem('notcord_pins', JSON.stringify(pinnedMessages));
        refreshPinnedUI();
        // visual feedback
        msgEl.style.outline = '2px solid rgba(88,101,242,0.12)';
        setTimeout(()=> msgEl.style.outline = '', 1200);
      });

      /***** Event wiring *****/
      channelsEl.addEventListener('click', (e)=>{
        const ch = e.target.closest('.channel');
        if(!ch) return;
        setActiveChannel(ch.dataset.id).catch(()=>{});
      });

      setNameBtn.addEventListener('click', async ()=>{
        let val = usernameInput.value.trim();
        if(!val) val = 'Guest' + Math.floor(Math.random()*9000+1000);
        if(val.length > NAME_MAX_LENGTH) val = val.slice(0, NAME_MAX_LENGTH);
        // set first time or obey weekly restriction if exists
        const lastChange = Number(localStorage.getItem(NAME_CHANGE_KEY) || 0);
        if(localStorage.getItem('notcord_username') && now() - lastChange < WEEK_MS){
          alert('Name can only be changed once per week.');
          return;
        }
        username = val;
        localStorage.setItem('notcord_username', username);
        localStorage.setItem(NAME_CHANGE_KEY, String(now()));
        usernameBox.style.display = 'none'; usernameLocked.style.display = 'flex'; usernameDisplay.textContent = username;
        if(avatarDataUrl) userAvatarSmall.src = avatarDataUrl; else userAvatarSmall.src = '';
        await upsertLocalPlayer(); await setLocalPlayerOnlineState(true); startHeartbeat(); await fetchPlayers(); updateCharCountAndState();
      });

      changeNameBtn.addEventListener('click', ()=>{
        // allow changing name if weekly passed
        const lastChange = Number(localStorage.getItem(NAME_CHANGE_KEY) || 0);
        if(!username){ alert('Set a username first'); return; }
        if(now() - lastChange < WEEK_MS){
          const remaining = Math.ceil((WEEK_MS - (now() - lastChange))/1000/60/60/24);
          alert('You can change name in ' + remaining + ' day(s).');
          return;
        }
        // show prompt to change
        const newName = prompt('Enter new name (max 8 characters):', username);
        if(newName){
          const v = newName.trim().slice(0, NAME_MAX_LENGTH);
          username = v;
          localStorage.setItem('notcord_username', username);
          localStorage.setItem(NAME_CHANGE_KEY, String(now()));
          usernameDisplay.textContent = username;
          await upsertLocalPlayer(); await setLocalPlayerOnlineState(true); fetchPlayers().catch(()=>{});
        }
      });

      avatarInput.addEventListener('change', async ()=>{
        if(!avatarInput.files.length) return;
        const lastAvatarChange = Number(localStorage.getItem(AVATAR_CHANGE_KEY) || 0);
        if(localStorage.getItem('notcord_avatar') && now() - lastAvatarChange < WEEK_MS){
          alert('Avatar can only be changed once per week.');
          avatarInput.value = '';
          return;
        }
        const file = avatarInput.files[0];
        try{
          const dataUrl = await resizeImageFileIfNeeded(file, 128, 128); // small avatar resize
          avatarDataUrl = dataUrl;
          localStorage.setItem('notcord_avatar', avatarDataUrl);
          localStorage.setItem(AVATAR_CHANGE_KEY, String(now()));
          if(username){
            userAvatarSmall.src = avatarDataUrl;
            await upsertLocalPlayer();
          }
          setStatus('Avatar updated');
        }catch(e){ console.error(e); alert('Failed to set avatar'); }
        avatarInput.value = '';
      });

      sendBtn.addEventListener('click', ()=>{
        const txt = messageInput.value;
        postMessage(txt);
        messageInput.value = ''; updateCharCountAndState(); clearReplyTo();
        const map = readTypingMap(); if(map[activeChannel] && map[activeChannel][username]){ delete map[activeChannel][username]; writeTypingMap(map); updateTypingUI(); }
      });

      messageInput.addEventListener('input', ()=>{
        updateCharCountAndState();
        if(username){
          const map = readTypingMap(); map[activeChannel] = map[activeChannel] || {}; map[activeChannel][username] = Date.now(); writeTypingMap(map); updateTypingUI();
        }
      });

      messageInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); if(!sendBtn.disabled) sendBtn.click(); } });

      photoInput.addEventListener('change', ()=> uploadPhotoBtn.disabled = !photoInput.files.length );
      uploadPhotoBtn.addEventListener('click', ()=> { if(photoInput.files.length) uploadPhoto(photoInput.files[0]); });

      nameColorInput.addEventListener('input', async (e)=>{ nameColor = e.target.value; localStorage.setItem('notcord_nameColor', nameColor); if(localPlayerId) await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', { name: username, lastSeen: new Date().toISOString(), nameColor }); Array.from(document.querySelectorAll('.meta .name')).forEach(el=>{ if(el.textContent===username) el.style.color = nameColor; }); fetchPlayers().catch(()=>{}); });
      resetNameColorBtn.addEventListener('click', ()=>{ nameColor='#ffcc00'; nameColorInput.value = nameColor; localStorage.setItem('notcord_nameColor', nameColor); });

      themeColor1Input.addEventListener('input', (e)=>{ themeColor1 = e.target.value; localStorage.setItem('notcord_theme1', themeColor1); accentColor = themeColor1; localStorage.setItem('notcord_accent', accentColor); applyTheme(); });
      resetTheme1Btn.addEventListener('click', ()=>{ themeColor1='#071226'; themeColor1Input.value = themeColor1; localStorage.setItem('notcord_theme1', themeColor1); applyTheme(); });
      themeColor2Input.addEventListener('input', (e)=>{ themeColor2 = e.target.value; localStorage.setItem('notcord_theme2', themeColor2); applyTheme(); });
      resetTheme2Btn.addEventListener('click', ()=>{ themeColor2='#07101a'; themeColor2Input.value = themeColor2; localStorage.setItem('notcord_theme2', themeColor2); applyTheme(); });
      themeColor3Input.addEventListener('input', (e)=>{ themeColor3 = e.target.value; localStorage.setItem('notcord_theme3', themeColor3); applyTheme(); });
      resetTheme3Btn.addEventListener('click', ()=>{ themeColor3='#0b2233'; themeColor3Input.value = themeColor3; localStorage.setItem('notcord_theme3', themeColor3); applyTheme(); });

      async function setActiveChannel(id){
        activeChannel = id; apiBase = CHANNELS[id] || null; localStorage.setItem('notcord_channel', id);
        Array.from(channelsEl.children).forEach(ch => ch.classList.toggle('active', ch.dataset.id === id));
        channelTitleEl.textContent = '# ' + id;
        updateInputArea();
        if(polling) clearInterval(polling);
        await fetchMessages();
        if(id !== 'photos') polling = setInterval(fetchMessages, 4000);
      }

      function cleanupTypingMap(){
        const map = readTypingMap(); const nowTs = now(); let changed = false;
        for(const ch of Object.keys(map)){ for(const u of Object.keys(map[ch])){ if(nowTs - map[ch][u] > TYPING_EXPIRE_MS){ delete map[ch][u]; changed = true; } } if(Object.keys(map[ch]).length===0) delete map[ch]; }
        if(changed) writeTypingMap(map);
        updateTypingUI();
      }

      /***** Initialization *****/
      async function init(){
        applyTheme(); initializeAppearanceInputs();
        // load pinned messages
        pinnedMessages = JSON.parse(localStorage.getItem('notcord_pins') || '[]');
        refreshPinnedUI();

        // restore user/avatar
        avatarDataUrl = localStorage.getItem('notcord_avatar') || '';
        if(username){ usernameBox.style.display='none'; usernameLocked.style.display='flex'; usernameDisplay.textContent = username; if(avatarDataUrl) userAvatarSmall.src = avatarDataUrl; await upsertLocalPlayer(); await setLocalPlayerOnlineState(true); startHeartbeat(); } else { usernameBox.style.display='flex'; usernameLocked.style.display='none'; }

        // show name change info
        updateNameChangeInfo();

        await setActiveChannel(activeChannel); await fetchPlayers(); if(playersPolling) clearInterval(playersPolling); playersPolling = setInterval(fetchPlayers, 5000);
        setInterval(cleanupTypingMap, 2000);
        setStatus('Connected (polling every 4s)');
      }
      init();

      function updateNameChangeInfo(){
        const lastName = Number(localStorage.getItem(NAME_CHANGE_KEY) || 0);
        const lastAvatar = Number(localStorage.getItem(AVATAR_CHANGE_KEY) || 0);
        const nameText = lastName ? ('Name changed: ' + new Date(lastName).toLocaleString()) : 'Name change available now';
        const avText = lastAvatar ? ('Avatar changed: ' + new Date(lastAvatar).toLocaleString()) : 'Avatar change available now';
        nameChangeInfo.textContent = nameText + ' ‚Ä¢ ' + avText;
      }

      // update name change info periodically
      setInterval(updateNameChangeInfo, 60*1000);

      // visibility API handling: when page hidden but computer on -> set idle indicator (yellow)
      document.addEventListener('visibilitychange', async ()=>{
        if(!username) return;
        if(document.hidden){
          // mark local player offline=false but idle (we set lastSeen but include a flag maybe)
          try{
            if(localPlayerId && navigator.sendBeacon){
              const url = `${PLAYERS_API}/${localPlayerId}`;
              const payload = JSON.stringify({ lastSeen: new Date().toISOString(), online:false, idle:true, name: username, nameColor, avatar: avatarDataUrl });
              const blob = new Blob([payload], { type: 'application/json' });
              navigator.sendBeacon(url, blob);
            } else {
              await setLocalPlayerOnlineState(false);
            }
          }catch(e){}
          stopHeartbeat();
        } else {
          // back to site
          await upsertLocalPlayer();
          startHeartbeat();
        }
      });

      // also when window unload, clear online
      window.addEventListener('beforeunload', ()=>{
        try{
          if(localPlayerId){
            const url = `${PLAYERS_API}/${localPlayerId}`;
            const payload = JSON.stringify({ lastSeen: new Date().toISOString(), online:false, idle:false, name: username, nameColor, avatar: avatarDataUrl });
            if(navigator.sendBeacon){
              const blob = new Blob([payload], { type: 'application/json' });
              navigator.sendBeacon(url, blob);
            } else {
              fetch(url, { method:'PUT', headers:{'Content-Type':'application/json'}, body: payload }).catch(()=>{});
            }
          }
        }catch(e){}
      });

      // Show idle in players list by translating idle flag into yellow marker (server changes not guaranteed in this mock API)
      // For local UI we mark ourselves idle if document.hidden
      setInterval(()=>{
        // update our local display dot next to our name in players list if hidden
        Array.from(playersListEl.querySelectorAll('.player')).forEach(item=>{
          const name = item.querySelector('.playerName')?.textContent || '';
          if(username && name.includes(username)){
            if(document.hidden){
              const dot = item.querySelector('.statusDot');
              if(dot){ dot.style.background = 'var(--idle-yellow)'; dot.style.boxShadow = '0 0 8px rgba(240,196,25,0.12)'; }
            }
          }
        });
      }, 2000);

      // expose some helpers for manual pin/unpin debugging
      window._notcord = { muteMap, fetchMessages, fetchPlayers, pinnedMessages };

    })();
  </script>
</body>
</html>
